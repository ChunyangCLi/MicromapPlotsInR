# Back to the Roots: Non-traditional Micromaps (for Viewing Patterns of Scientific Posters) {#Ch10}


\chapterauthor{Chunyang Li}


This chapter will introduce the reader how to create linked micromap plots from scratch without using any of the existing micromap R packages. This may become necessary when the underlying areas are not supported by any shapefile or other boundary file, e.g., positions on a baseball field or locations of stores in a shopping mall, or when non-standard visualizations are required, e.g., the in-flow or out-flow of a spatial area. This chapter will focus on linked microposter plots, i.e., linked micromap plots where the areas of interest are the main viewing areas of a scientific poster.



## Introduction {#Ch10-Introduction}

The linked micromap plot was first introduced in 1996 to highlight geographic patterns and associations among the variables in a spatial dataset [@CaPi1996]. It has been widely used to display geospatially-indexed summary statistics. For some in-depth discussion of linked micromap plots, the reader is referred to @SC2008, @CP2010, @SDWPM2014	, @SCMW2017, and the other chapters of this book.  

According to @CP2010, the linked micromap plots can represent any two-dimensional space, not just latitude-longitude on the Earth's surface, such as positions on a baseball field or locations of stores in a shopping mall, or the in-flow or out-flow of a spatial area, etc. Based on this idea, @LiSy2016ASA proposed a linked microposter plot to visualize eye tracking data of how people look at scientific posters, considering a poster as a map and the Area Of Interests (AOIs) of the poster as the different countries or states. Linked microposter plot is able to more effectively presenting eye tracking data compared to the commonly used eye tracking visualizations. @LiSy2017ASA proposed **EyeTrackR**\index{R Packages!EyeTrackR}, an R package for eye tracking data visualizations including linked microposter plot, and @SLZSM2017ASA applied **EyeTrackR** to create linked microposter plot to visualize how people look at posters of yoga postures.


The following sections will illustrate how to create linked micromap plots from scratch using the creation of linked microposter plot as an example. The goal is to help users be able to change the code to create other types of linked micromap plot of their interests. 
<!-- The creation of linked microposter is based on the raw code from @LiSy2017ASA before compiling the R package. -->



## Main {#Ch10-Main}


### Data processing and preparation {#Ch10-Data}

#### Eye tracking data
Eye tracking data is obtained from measuring where people are looking at with an eye tracking device, either a mobile eye tracker or a static eye tracker. Static eye trackers are based on a desktop, hence they are often used to study eye motion on a computer screen. Mobile eye trackers are fixed on a user's head, so they are not limited within a restricted area and can be used for a variety of activities, such as playing soccer, driving, etc. The example data we use to demonstrate are from a 30 Hz mobile eye tracker that records 30 images per second. The two co-authors of @LiSy2017ASA looked at a series of statistical and other scientific posters. The original data is a video record indicating where people are looking at. The video data is processed with matlab and we are able to obtain a dataframe with x and y coordinates transformed to the same coordinate system in terms of the poster we defined. The details of processing the raw video data is described in @Li2017. Time series pupil radius data are also obtained from the eye tracker.

The eye tracking data for the poster we use to demonstrate here is based on a controlled experiment where the participant was given instructions to look at the poster. 



#### Shapefile preparation: AOI definition

The shapefiles for the micro poster plot is the boundaries of the areas of interests (AOIs) for the poster, such as the title, logos, multiple text areas, images, and tables. 

<!-- The AOIs of the posters can be automatically defined with the \textit{DrawAOIs} function in **EyeTrackR**\index{R Packages!EyeTrackR} R package.  -->
The rectangles that represent the AOIs are drawn by mouse clicking two vertices using the _locator_ function in base R graphics [@RCore2017], which is able to return coordinates with the mouse click. The AOIs are named by the analyst, 
<!-- The \textit{DrawAOIs} function used __locator__ function in base R graphics [@RCore2017], which is able to return coordinates with the mouse click.  -->
Based on the coordinates of two vertices, we are able to create the boundaries of a rectangle that are used as shapefile of the map. Table \@ref(tab:Ch10-aoi-data) shows two of the AOIs definitions considered as the shapefile for the poster and will be used for the microposter plot creation. 
<!-- The code for **EyeTrackR**\index{R Packages!EyeTrackR} R package is available on Github (https://github.com/ChunyangCLi/EyeTrackR.git). -->

The user can create self-defined shapefile based on their own needs, for example, defining different locations of the stores or spots in a baseball field. The output similar to the AOIs from Table \@ref(tab:Ch10-aoi-data) can be directly used to generate the micromap plot, which contains the names of the AOIs and the x, y coordinates of the vertices of the AOIs. The coordinates start with one vertex and end with the coordinates of the same vertex. Each AOI is separated by a line with "NA"s. 
According to @CP2010 and @PMWOK2015JSS, "the polygons displayed in the maps of micromaps only need to be detailed enough to convey shape and relative position of the areas and provide a spatial framework by identifying neighboring polygons". 
<!-- If the polygons one is interested to create are all rectangles, the _DrawAOIs_ function from base R can be used to extract the point coordinate in order to create the shape file.  -->
<!-- Here is the code we used to create poster shape files for eye tracking data. -->
Twelve AOIs are defined on the poster image and the shape data is saved as``AOIName.rda''.


```{r Ch10-aoi-data, eval = TRUE, echo = FALSE}

RegionName <- read.csv("data/Ch10/RegionName.csv")
# load(file = "fig_10/RegionName.RData")

knitr::kable(
  RegionName, 
  caption = "An example of shapefile for micromap plot.",
  booktabs = TRUE
)

```


Figure\@ref(fig:Ch10-poster-AOI) shows the twelve defined AOIs of the poster. The red bounding boxes outline the defined AOIs. An additional AOI, called ``Blank'', contains all the empty space between these main AOIs, so that the entire poster is covered. The poster is used to test the data processing results and the validity of the linked microposter plot. The participant is timed to look at eight of the AOIs for about six seconds and at four of the AOIs for about two seconds.  Overall, the participants looked at Poster 1 for about 56 seconds resulting in a total of 1680 video frames, so there will be around 1680 rows of x and y coordinates after the video processing. 


```{r Ch10-poster-AOI, fig.cap = 'Poster with defined AOIs.', out.width = '90%', eval = TRUE, echo = FALSE}

options(knitr.graphics.auto_pdf = TRUE)
knitr::include_graphics("img/Ch10-AOI_boxes.pdf")
```

#### Eye tracking data feature extractions

The processed video data is still considered raw eye tracking data, which is a time series of x and y coordinates. To create linked micromap plot, the data features should be extracted based on the defined Region of Interests or AOIs. Different features of eye tracking data are extracted in terms of the defined AOIs, such as how long the participant has spent and how many times the participant has visited each AOI, eye movement speed from one focus point to another in pixels within each AOIs and pupil radiuses for each visit at the corresponding AOI. 

The resulting datasets described in the above sections are provided to create a sample linked micromap plot or linked micro poster plot:  _AOIName_\index{Datasets!AOIName} is the shapefile; _locations_testing_\index{Datasets!locations\_testing} is the time series of the x and y coordinates indicating where the participant is looking at on the poster; _posterdat.all_\index{Datasets!posterdat.all} is the list with features extracted from _locations_testing_ dataset. _Posterdat.all_ contains three lists: 1. A dataframe with three columns: section (AOI names), visits or time the participant spent on each AOI (in seconds), and visits.num indicating how many times the participant has visited each AOI. 2. A list of eye movement speed for each AOIs (each AOI is a list). 3. A list of pupil radius for each AOIs (each AOI is a list). 


### Linked microposter plot creation

After the eye tracking video data is processed and AOI shapefile is created, we can now start to create linked microposter plot following the steps below. 

1. **Panel design specification.**
    
First, the user needs to figure out a few questions: What panels are there in the plot? i.e. how many and what variables does one want to visualize? What are the plot types one wants to use for the visualization? How to arrange the panels, such as which panel goes left and which panel goes right? How does one want to label the panels? 

A vector of panel plot types are created to store the designed panel types. Then a list of column attributes are created to specify the order of the panels from left to right using a _col.num_. For the poster panel, _cumulate_ is an attribute that determines if one wants cumulative pattern or not. For each panel, one needs to specify the header of the panel, and the font of the labeling. For the data panels, the data needs to be specified. Below is the code how the linked microposter plot panels are specified. Here we are creating three data panels: two dot plot panels representing number of visits and length of visits, and one boxplot panel representing pupil data. The poster, legend and the data panels are presented from left to right. After the panel types and attributes are specified, a quick check is conducted to make sure that all the panel types one plans to plot are specified. 


```{r Ch10-panel-design}

panel.types = c("poster", "legend", "dot", "dot", "boxplot")

columns.att = list(
  list(col.num = 1, cumulate = TRUE),
  list(col.num = 2, header = "Areas of Interest", header.size = 0.7, point.size = 0.96, text.size = 0.7, text.font = 1),
  list(col.num = 3, panel.data = "visits.num", header = "Number of Visits", text.size = 0.7, point.size = 0.96, axis.ticks = NA, axis.labels = NA),
  list(col.num = 4, panel.data = "visits", header = "Length of Visits (sec)", text.size = 0.7, point.size = 0.96, axis.ticks = NA, axis.labels = NA),
  list(col.num = 5, panel.data = "pupildat", header = "Pupil Radius in Pixels", text.size = 0.7, axis.ticks = NA, axis.labels = NA)
)

columns = length(columns.att)
if (length(panel.types) < columns){
  warning("Panel types are not completely specified.")
}

```


2. **Load images and data.**

After specifying the panels, the image/poster and data need to be loaded. The poster image is changed to grayscale. We used **imager**\index{R Packages!imager} R package for the poster image processing such as changing the colored poster to grayscale in order to lay other colors on top. The user can replace poster with other images and replace eye tracking data with other data types. 


```{r Ch10-load-data}
library(imager)

load(file = "data/Ch10/posterdat.all.rda")
poster.loc = "img/Ch10-poster_colored.jpg"
posterdat = posterdat.all[[1]]
names(columns.att) = panel.types
poster = imager::load.image(poster.loc)
poster = imager::grayscale(poster)

```

3. **Load shapefile for poster.**

The shape file, i.e. data for the definitions of AOIs, is loaded. The AOIs are like states for the map of the united states and the poster is like the nation. The boarders for the entire poster is also defined as a dataframe for the plotting. The AOI "Blank" is added to the shape file with its vertices defined as 0s. A polygon for the entire poster is created after the creation and loading the polygons for all the AOIs.   


```{r Ch10-load-shapefile}
load("data/Ch10/AOIName.rda")
posterVBorders = AOIName

# create shape data for blank and add it to poster shapefile
blank = as.data.frame(matrix(c(rep(0, 5 * 3), NA, NA, NA), nrow = 6, ncol = 3, byrow = TRUE))
blank[, 1] = "Blank"
colnames(blank) = colnames(posterVBorders)
stateVBorders = rbind(posterVBorders, blank)

# create the polygon for the entire poster
nationVBorders = matrix(c(0, 0, imager::width(poster), 0, imager::width(poster), imager::height(poster), 0, imager::height(poster), 0, 0), nrow = 5, ncol = 2, byrow = TRUE)
nationVBorders = as.data.frame(nationVBorders)
colnames(nationVBorders) = c("x", "y")

```


4. **Sort rows according to data columns.**

The user can specify how they want the rows to be sorted by, i.e., which column to order by. In this case, can choose one from the three variables we visualize: number of visits (visits.num), length of visits (visits) or pupil radiuses (pupildat) to sort by. The variable ``visits'' is chosen to sort the rows for the plot as an example. The code is also provided if one wants to sort the rows by the other two variables.  


```{r Ch10-sort-rows}

sortby = "visits"
decreasing = TRUE

if (sortby == "pupildat"){
  unordered.median = unlist(lapply(pupildat, stats::median))
  ordered.median = order(unordered.median, decreasing = decreasing)
  pupildat = pupildat[ordered.median]
  posterdat = posterdat[ordered.median, ]
} else if (sortby == "speed"){
  unordered.median = unlist(lapply(speed, stats::median))
  ordered.median = order(unordered.median, decreasing = decreasing)
  speed = speed[ordered.median]
  posterdat = posterdat[ordered.median, ]
} else {
  posterdat = posterdat[order(posterdat[, sortby], decreasing = decreasing), ]
}

```


5. **Determine panel layouts.**

The quickest approach is to use automatic layout and choose different partitioning described in @PMWOK2015JSS, here we chose the automatic layout and set the partitioning to be 1. The user can also specify layout of the rows, and if median row is wanted or not. Then the sizes of the each rows are calculated based on the overall plot size and the number of rows for the aesthetics of the plot. The code for the functions _panelLayout_, _DetermineMedianRow_, and _ArrangePanels_, as well as the layout details list is in the SharedFunctions.R file provided with the book. There is no need to make changes to these functions, unless more changes on the layout are desired.  



```{r Ch10-panel-layout}
source("R/Ch10_SharedFunctions.R")
stateDataId = row.names(posterdat) 
Layout = NA
MedianRow = TRUE
AutomaticLayout = TRUE
partitioning = 1

# determine the layouts
 if (AutomaticLayout){
   rows = ArrangePanels(posterdat = posterdat, partitioning)[[3]]
   MedianRow = DetermineMedianRow(nrow(posterdat), partitioning)
 } else {
   rows = length(Layout)
   if (length(hdColors) < max(Layout)){
     hdColors = rep(hdColors, ceiling(max(Layout)/length(hdColors)))
     warning('There are too few colors provided.')
   }
 }

 if ((AutomaticLayout == FALSE) && MedianRow){
   if ((rows %% 2 == 0) || (Layout[ceiling(length(Layout)/2)] != 1)){
     MedianRow = FALSE
     warning("There is no median row.")
   }
 }
 
# determine the size of the rows    
if (MedianRow == FALSE){
  rowsize = rep(17.2/rows, rows)
} else {
  rowsize = c(rep(17.2/rows, floor(rows/2)), 17.2/(rows*3.2), rep(17.2/rows, floor(rows/2)))
}
  
```


6. **create panel layouts and plot indexes.**

Details is a list structure that contains the variables and values for the detailed layout of the plot. _ArrangePanels_ function is able to automatically determine the start and end rows for each plot groups given the input: iBegin and iEnd. The content are arranged into 3 perceptual groups. 


```{r Ch10-panel-layout-and-plot-indexes}

panel.width = c(2.9, 2.9, 2.9, 2.9, 2.9)
panels = panelLayout(nrow = rows, ncol = columns, topMargin = details$top, bottomMargin = details$bot, leftMargin = details$left, rightMargin = details$right, rowSep = rep(0.01, rows + 1), rowSize = rowsize,
                     colSize = panel.width, colSep = rep(0.05, (columns + 1)))

iBegin = ArrangePanels(posterdat = posterdat, partitioning, AutomaticLayout, Layout, MedianRow)[[1]]
iEnd = ArrangePanels(posterdat = posterdat, partitioning, AutomaticLayout, Layout, MedianRow)[[2]]
nGroups = length(iEnd)
```

7. **Plot posters.**

After all the settings are specified, we can now start to plot the linked microposter plot each column at a time, by starting from the leftmost column, i.e., the micro posters. The microposter plots code are structured similar to the _lmplot_ function provided by @PaOl2015.     

A _microposters_ function is created to plot the poster column. If the user keep the similar data structure as the eye tracking data demonstrated, dataframe, column names, and image types, then there is no need to adjust this function to visualize other topic of interest, otherwise, one will need to adjust the data and column names accordingly. 

The microposter column with small posters is plotted with highlights according to the context and labels. panel.col is the column number of this panel that is defined with the column attributes, the rest of the inputs are the attributes also specified in the above sections. First, the labels are specified. One can adjust the texts inside the function. Then the microposters with specific highlights are created by the perceptual groups divided with a for loop in the code. In this example, there are 3 perceptual groups and no median row. For each group, we color the AOIs presented in the group, the rest AOIs are either gray as background or colored in light yellow if they have been presented in the previous groups. The borders of each AOIs and the entire poster are plotted with thick black lines.In the function _microposters_, the explanations of the important variables are listed below: 
* gsubs: the row index for current group;
* back: the row index for the AOIs that are not presenting in the current group;
* fore: the complement of "back", i.e., the row index for the AOIs that are presenting in the current group;
* pen: the index to determine which color to use in the selected color scheme "hdColors".
* past: index for cumulative AOIs shown above. 

```{r Ch10-create-microposter}

microposters <- function( panel.col,
                         cumulate = TRUE,
                         posterdat = posterdat,
                         stateVBorders,
                         nationVBorders,
                         poster,
                         panels,
                         nGroups,
                         rows,
                         MedianRow,
                         iBegin,
                         iEnd,
                         hdColors){

  # polygon id's one per polygon
  polygonId = stateVBorders$section[is.na(stateVBorders$x)]

  # panel titles
  panelSelect(panels, 1, panel.col)
  panelScale()
  if (MedianRow == TRUE) {
    graphics::mtext(side = 3, line = details$line1, "Above Median Visits", cex = details$cex)

    if(cumulate){
    graphics::mtext(side = 3, line = details$line2, "Cumulative Microposters", cex = details$cex)
    }

  } else {

    if(cumulate){
    graphics::mtext(side = 3, line = details$line1, "Cumulative Microposters", cex = details$cex)
    }

  }

  panelSelect(panels, nGroups, panel.col)
  panelScale()

  if (MedianRow == TRUE) {
    graphics::mtext(side = 1, line = details$line3, "Below Median Visits", cex = details$cex)
  }

  rxpoly = range(nationVBorders$x, na.rm = TRUE)
  rypoly = range(nationVBorders$y, na.rm = TRUE)

  # plot by perceptual groups
  for (i in 1:nGroups) {

    if (MedianRow == TRUE && i == ceiling(nGroups/2)){

      # map not drawn, median region in adjacent panel
      panelSelect(panels, (nGroups + 1)/2, panel.col)
      panelScale()
      panelFill(col = details$wgray)
      panelOutline(col = "black")
      graphics::text(0.5, 0.55, "Median", cex = details$cex)
      next

    }

    panelSelect(panels, i, panel.col)
    panelScale(rxpoly, rypoly)
    gsubs = iBegin[i]:iEnd[i]
    median_group = iBegin[ceiling(nGroups/2)]

    if (MedianRow == TRUE){
      if (i == ceiling(nGroups/2) - 1)
        gsubs = c(gsubs, median_group)  # median region added here
      if (i == ceiling(nGroups/2) + 1)
        gsubs = c(gsubs, median_group)  # median region added here
    }

    panelNames = posterdat$section[gsubs]

    # plot background image
    graphics::rasterImage(poster, 0, 0, imager::width(poster), imager::height(poster))

    # plot background (out of contour) regions in gray with white outlines
    # frontRegions are the regions in the group, the rest are back
    frontRegions = posterdat$section[1:iEnd[i]]
    back = is.na(match(stateVBorders$section, frontRegions))
    graphics::polygon(stateVBorders$x[back], stateVBorders$y[back], border = TRUE)

    # plot foreground regions for the panel in their special colors pens 1:5 and other in contour regions in light yellow
    fore = !is.na(match(stateVBorders$section, panelNames))
    pen = match(polygonId, panelNames, nomatch = 10)[!is.na(match(polygonId, panelNames))]
    # outline regions
    if (MedianRow){
      pen[which(pen == median_group)] = length(hdColors)
    }
    graphics::polygon(stateVBorders$x[fore], stateVBorders$y[fore], col = scales::alpha(hdColors[pen], 0.7), border = FALSE)
    # plot borders
    graphics::polygon(stateVBorders$x[fore], stateVBorders$y[fore], col = "black", density = 0, lwd = 1)
    # plot past regions
    if (cumulate){
      past = !back & !fore
      graphics::polygon(stateVBorders$x[past], stateVBorders$y[past], col = scales::alpha(details$wyellow, 0.7), border = FALSE)
      graphics::polygon(stateVBorders$x[past], stateVBorders$y[past], col = "black", density = 0, lwd = 1)
    }
    # outline poster
    graphics::polygon(nationVBorders$x, nationVBorders$y, col = "black", density = 0, lwd = 1)

  }
}


```


Now we can apply the function to create our first column: microposter column. The color series are selected from the **RColorBrewer**\index{R Packages!RColorBrewer} R package. In this example, 5 colors are used in the ``Accent'' color series, since we have five rows at most for each perceptual group. Multiple microposter columns can be created if one specify them.


```{r Ch10-create-microposters, fig.cap = 'Plot posters.'}
    
hdColors = rev(RColorBrewer::brewer.pal(5, "Accent"))

  if (sum(panel.types == "poster") >= 1){

    posters = which(panel.types == "poster")

    for (i in 1:length(posters)){

  microposters(panel.col = columns.att[posters[i]]$poster$col.num,
               cumulate = columns.att[posters[i]]$poster$cumulate,
               posterdat = posterdat,
               stateVBorders,
               nationVBorders,
               poster,
               panels,
               nGroups,
               rows,
               MedianRow,
               iBegin,
               iEnd,
               hdColors)

    }
  }


```


8. **Plot labels.**

After plotting the poster image column, we can plot the labels or the legends. Similarly, we created a function _m.labels_ to make the plotting process cleaner and easier to reuse. The function is structured similarly as the _microposters_ function, also the variable naming schemes. First, we define the label content and aesthetics such as font and size. Then we create the labels with a for-loop in the code based on the perceptual groups. The ``Blank'' AOI is defined separately as we want it to be white color, which is not in the color series we chose. 


```{r Ch10-crerate-label-function}

m.labels <- function(panel.col,
                     title,
                     header.size = 0.7,
                     cex = 0.7,
                     dcex = 0.96,
                     font = 1,
                     posterdat = posterdat,
                     stateVBorders,
                     nationVBorders,
                     panels,
                     nGroups,
                     MedianRow,
                     iBegin,
                     iEnd,
                     hdColors){
  
  stateNames = posterdat$section 
  panelSelect(panels, 1, panel.col)
  panelScale()
  
  if (MedianRow){
    graphics::mtext(side = 3, line = details$line2, title, cex = header.size)
  } else {
    graphics::mtext(side = 3, line = details$line1, title, cex = header.size)
  }
  
  for (i in 1:nGroups) {
    
    gsubs = iBegin[i]:iEnd[i]
    gnams = posterdat$section[gsubs]
    nsubs = length(gnams)
    pen = 1:nsubs
    laby = nsubs:1
    
    panelSelect(panels, i, panel.col)
    panelScale(c(0, 1), c(1 - details$ypad, nsubs + details$ypad))
    
    if (MedianRow == TRUE && i == ((nGroups + 1)/2)){
      pen = length(hdColors)
    }
    
    for (j in 1:length(pen)) {
      graphics::points(0.1, laby[j], pch = 16, col = hdColors[pen[j]], cex = dcex)
      graphics::points(0.1, laby[j], pch = 1, col = "black", cex = dcex)
      graphics::text(0.18, laby[j] + details$nameShift, gnams[j], cex = cex, adj = 0, col = "black", font = font)
      
      if (gnams[j] == "Blank") {
        graphics::points(0.1, laby[j], pch = 16, col = "white", cex = dcex)
        graphics::points(0.1, laby[j], pch = 1, col = "black", cex = dcex)
      }
      
    }
  }
}

```


Now the function can be executed and the labels and the legends column can be plotted.   
```{r Ch10-plot-labels, eval = F}

if (sum(panel.types == "legend") >= 1){

  legends = which(panel.types == "legend")

  for (i in 1:length(legends)){

      m.labels(panel.col = columns.att[legends[i]]$legend$col.num,
               title = columns.att[legends[i]]$legend$header,
               header.size = columns.att[legends[i]]$legend$header.size,
               cex = columns.att[legends[i]]$legend$text.size,
               dcex = columns.att[legends[i]]$legend$point.size,
               font = columns.att[legends[i]]$legend$text.font,
               posterdat = posterdat,
               stateVBorders,
               nationVBorders,
               panels,
               nGroups,
               MedianRow,
               iBegin,
               iEnd,
               hdColors)

    }
  }
```

```{r Ch10-create-microposters-and-labels, echo = F, fig.cap = 'Plot labels.'}
    
hdColors = rev(RColorBrewer::brewer.pal(5, "Accent"))

  if (sum(panel.types == "poster") >= 1){

    posters = which(panel.types == "poster")

    for (i in 1:length(posters)){

  microposters(panel.col = columns.att[posters[i]]$poster$col.num,
               cumulate = columns.att[posters[i]]$poster$cumulate,
               posterdat = posterdat,
               stateVBorders,
               nationVBorders,
               poster,
               panels,
               nGroups,
               rows,
               MedianRow,
               iBegin,
               iEnd,
               hdColors)

    }
  }

if (sum(panel.types == "legend") >= 1){

  legends = which(panel.types == "legend")

  for (i in 1:length(legends)){

      m.labels(panel.col = columns.att[legends[i]]$legend$col.num,
               title = columns.att[legends[i]]$legend$header,
               header.size = columns.att[legends[i]]$legend$header.size,
               cex = columns.att[legends[i]]$legend$text.size,
               dcex = columns.att[legends[i]]$legend$point.size,
               font = columns.att[legends[i]]$legend$text.font,
               posterdat = posterdat,
               stateVBorders,
               nationVBorders,
               panels,
               nGroups,
               MedianRow,
               iBegin,
               iEnd,
               hdColors)

    }
  }
```


9. **Other columns.**

In this example, we presented dotplot and boxplot to visualize the visits and the pupil radiuses. Similar to the _microposters_ and _m.labels_ functions, we first specify some labels (axis, axis ticks, and labels) and then plot each dot or boxplot one by one with the corresponding colors within each perceptual group. Since we chose white color for blank, therefore, it is coded as a special case. 

For the _m.dotplot_ function, the axis range as well as the panel grid are automatically determined by the range of the input data. Axis range is set to be slightly below the minimum and above the maximum. Then the grid in panels are determined by evenly dividing the panel width. Then we manually plot the panel grid and the axis ticks and labels at the last perceptual group. Finally, the dots are plotted using the _points_ fuction and connected with black lines.    

For the _m.boxplot_ function, the dataframe is specified within the data list, then the plotting parameters are defined for the boxplot. Similarly to the _m.dotplot_, the panel grid and axis lables are created. Then the boxplots are created manually by first plotting the outliers, and then the dots. 

```{r Ch10-dotplot-boxplot-functions}

m.dotplot <- function(var,
                      posterdat,
                      panel.num,
                      title,
                      cex = 0.7,
                      dcex = 0.96,
                      axis.ticks = NA,
                      axis.labels = NA,
                      panels,
                      nGroups,
                      MedianRow,
                      iBegin,
                      iEnd,
                      hdColors){

  var = posterdat[, var]
  sectionNames = posterdat$section
  countRange = range(var)
  countRange = mean(countRange) + 1.3 * diff(countRange) * c(-0.5, 0.5)
  if(is.na(axis.ticks)){
    countGrid = panelInbounds(countRange)  # used pretty values that are in bounds
  } else {
    countGrid = axis.ticks
  }

  panelSelect(panels, 1, panel.num)
  panelScale()
  graphics::mtext(side = 3, line = details$line1, text = title, cex = cex)

  for (i in 1:nGroups) {
    gsubs = iBegin[i]:iEnd[i]
    gnams = sectionNames[gsubs]
    nsubs = length(gsubs)
    pen = 1:nsubs
    laby = nsubs:1
    panelSelect(panels, i, panel.num)
    countRange2 = c(min(countGrid) - mean(countGrid)*0.28, max(countGrid) + mean(countGrid)*0.28)
    panelScale(countRange2, c(1 - details$ypad, nsubs + details$ypad))
    panelFill(col = details$wgray)
    panelGrid(x = countGrid, col = "white")
    panelOutline(col = "white")

    if (i == nGroups) {
      if (is.na(axis.labels)){
        graphics::axis(side = 1, at = countGrid, labels = as.character(countGrid), col = "black", mgp = c(1, 0, 0),
             tck = -0.04, cex.axis = cex)
      } else {
        graphics::axis(side = 1, at = countGrid, labels = as.character(axis.labels), col = "black", mgp = c(1, 0, 0),
             tck = -0.04, cex.axis = cex)
      }
    }

    if (MedianRow == TRUE & i == ((nGroups + 1)/2))
      pen = length(hdColors)
    graphics::lines(var[gsubs], laby, col = "black", lwd = 1)

    for (j in 1:length(pen)) {
      graphics::points(var[gsubs[j]], laby[j], pch = 16, cex = dcex, col = hdColors[pen[j]])
      graphics::points(var[gsubs[j]], laby[j], pch = 1, cex = dcex, col = "black")
      if (gnams[j] == "Blank") {
        graphics::points(var[gsubs[j]], laby[j], pch = 16, cex = dcex, col = "white")
        graphics::points(var[gsubs[j]], laby[j], pch = 1, cex = dcex, col = "black")
      }
    }

  }
}


m.boxplot <- function(dat,
                      posterdat,
                      panel.num,
                      text.size = 0.7,
                      panels,
                      title,
                      axis.ticks = NA,
                      axis.labels = NA,
                      nGroups,
                      MedianRow,
                      iBegin,
                      iEnd,
                      hdColors) {

  if (dat == "speed"){
    dat = posterdat[[2]]
  } else if (dat == "pupildat"){
    dat = posterdat[[3]]
  }

  sectionNames = posterdat[[1]]$section
  # box plot parameters
  thinBox = .2                 
  thickBox = .60   
  useBlack = FALSE    # for outliners
  medianLine = .88
  colDotMedian = "white"
  pchMedian = 19
  cexMedian = .95
  lwdMedian = 2
  colMedian = "white"
  cexOutlier = .6 # see cexDot  
  lwdOutlier = .4               
  sc = 1.3
  pad = .67       # y axis padding for integer plotting locates
  lwdGrid = 1

  boxlist = graphics::boxplot(dat, plot = FALSE)
  # y boxplot scaling              
  # standard - horizontal box - no vertical (y) dimensions
  py = c(-.5, -.5, .5, .5)
  thiny = thinBox*py
  thicky = thickBox*py
  medy = medianLine*c(-.5, .5)
  ry = c(0, 1)                      # used in y scaling for grid lines

  #_______________Gather stats and put in State Order______________

  # For the moment match on names
  # Boxlist = names, stats, out, group,
  stats = boxlist$stats       # Name,1-low,2-25%,3-median,4-75%,5-high  - 5 variables for each state.
  thin = stats[c(1, 5, 5, 1 ), ]   # a column for each state - thin line - outliers - columns in boxlist (1,5,5,1)
  thick = stats[c(2, 4, 4, 2), ]  # a column for each state - thick line - 25% to 75% - columns in boxlist(2,4,4,2)
  med = stats[3, ]             # a single value for each state (median)
  nam = boxlist$names         # state name.

  outlier = rep(FALSE, length(med))
  if(!is.null(boxlist$out)){
    out = boxlist$out
    group = boxlist$group
    outlier[unique(group)] = TRUE
  }

  # Need to put data in order
  ord = match(sectionNames, nam)

  if(is.null(out)) rx = range(stats) else
    rx  = range(stats, out)
  countRange  = sc*diff(rx)*c(-.5,.5) + mean(rx)

  if(is.na(axis.ticks)){
    countGrid = panelInbounds(countRange)  # used pretty values that are in bounds
  } else {
    countGrid = axis.ticks
  }

  panelSelect(panels, 1, panel.num)
  panelScale()
  graphics::mtext(side = 3, line = details$line1, text = title, cex = text.size)

  for (i in 1:nGroups) {
    gsubs = iBegin[i]:iEnd[i]
    nsubs = length(gsubs)
    gnams = sectionNames[gsubs]
    pen = 1:nsubs
    laby = nsubs:1
    panelSelect(panels, i, panel.num)
    countRange2 = c(min(countGrid) - stats::median(countGrid)*0.05, max(countGrid) + stats::median(countGrid)*0.05)
    panelScale(countRange2, c(1 - details$ypad, nsubs + details$ypad))
    panelFill(col = details$wgray)
    panelGrid(x = countGrid, col = "white")
    panelOutline(col = "white")
    if (i == nGroups) {
      if(is.na(axis.labels)){
        graphics::axis(side = 1, at = countGrid, labels = as.character(countGrid), col = "black", mgp = c(1, 0, 0),
             tck = -0.04, cex.axis = text.size)
      } else {
        graphics::axis(side = 1, at = countGrid, labels = as.character(axis.labels), col = "black", mgp = c(1, 0, 0),
             tck = -0.04, cex.axis = text.size)
      }
    }

    if (MedianRow == TRUE & i == ((nGroups + 1)/2)){
      pen = length(hdColors)
    }

    for (k in 1:length(pen)){

      m = ord[gsubs[k]] #m is the location of the state in boxlist
      if(is.na(m)) next
      kp = pen[k]      # color number
      ht = laby[k]


      if(outlier[m]){
        vals = out[group == m]
        if (gnams[k] == "Blank"){
          graphics::points(vals, rep(ht,length(vals)), pch = 1,
                 col = ifelse(useBlack, "black", "#FFFFFF"),
                 cex = cexOutlier,lwd = lwdOutlier)
        } else {
          graphics::points(vals, rep(ht, length(vals)), pch = 1,
                 col = ifelse(useBlack, "black", hdColors[kp]),
                 cex = cexOutlier,lwd = lwdOutlier)
        }
      }

      if (gnams[k] == "Blank"){

        graphics::polygon(thin[, m], rep(ht, 4) + thiny, col = "#FFFFFF", border = NA)
        graphics::polygon(thick[, m], rep(ht, 4) + thicky, col = "#FFFFFF", border = NA)
        graphics::segments(med[m], ht + medy[1], med[m], ht + medy[2],
                 col = "black", lwd = lwdMedian)

      } else {

        graphics::polygon(thin[,m], rep(ht, 4) + thiny,col = hdColors[kp], border = NA)
        graphics::polygon(thick[,m], rep(ht, 4) + thicky,col = hdColors[kp], border = NA)
        graphics::segments(med[m],ht + medy[1], med[m], ht + medy[2],
                 col = "black",lwd = lwdMedian)

      }
    }

  }
}
```

There are two columns visualized with dotplot: the length of time spent in each AOI and the number of times each AOI is visited. The two columns are plotted by calling the _m.dotplot_ function within the for loop. 
```{r Ch10-dotplot, eval=F}

  # Plot percent of visits___________________________________
  if (sum(panel.types == "dot") >= 1){

   dots = which(panel.types == "dot")

   for (i in 1:length(dots)){

   m.dotplot(var = columns.att[dots[i]]$dot$panel.data,
          posterdat,
          panel.num = columns.att[dots[i]]$dot$col.num,
          title = columns.att[dots[i]]$dot$header,
          cex = columns.att[dots[i]]$dot$text.size,
          dcex = columns.att[dots[i]]$dot$point.size,
          axis.ticks = columns.att[dots[i]]$dot$axis.ticks,
          axis.labels = columns.att[dots[i]]$dot$axis.labels,
          panels,
          nGroups,
          MedianRow,
          iBegin,
          iEnd,
          hdColors)
   }
    }


```

```{r Ch10-dotplot-cum, echo=F, fig.cap = 'Add two dotplot columns.'}
  if (sum(panel.types == "poster") >= 1){

    posters = which(panel.types == "poster")

    for (i in 1:length(posters)){

  microposters(panel.col = columns.att[posters[i]]$poster$col.num,
               cumulate = columns.att[posters[i]]$poster$cumulate,
               posterdat = posterdat,
               stateVBorders,
               nationVBorders,
               poster,
               panels,
               nGroups,
               rows,
               MedianRow,
               iBegin,
               iEnd,
               hdColors)

    }
  }
  

  # Plot labels____________________________________________________________

  if (sum(panel.types == "legend") >= 1){

    legends = which(panel.types == "legend")

    for (i in 1:length(legends)){

  m.labels(panel.col = columns.att[legends[i]]$legend$col.num,
           title = columns.att[legends[i]]$legend$header,
           header.size = columns.att[legends[i]]$legend$header.size,
           cex = columns.att[legends[i]]$legend$text.size,
           dcex = columns.att[legends[i]]$legend$point.size,
           font = columns.att[legends[i]]$legend$text.font,
           posterdat = posterdat,
           stateVBorders,
           nationVBorders,
           panels,
           nGroups,
           MedianRow,
           iBegin,
           iEnd,
           hdColors)

    }
  }



  # Plot percent of visits___________________________________
  if (sum(panel.types == "dot") >= 1){

   dots = which(panel.types == "dot")

   for (i in 1:length(dots)){

   m.dotplot(var = columns.att[dots[i]]$dot$panel.data,
          posterdat,
          panel.num = columns.att[dots[i]]$dot$col.num,
          title = columns.att[dots[i]]$dot$header,
          cex = columns.att[dots[i]]$dot$text.size,
          dcex = columns.att[dots[i]]$dot$point.size,
          axis.ticks = columns.att[dots[i]]$dot$axis.ticks,
          axis.labels = columns.att[dots[i]]$dot$axis.labels,
          panels,
          nGroups,
          MedianRow,
          iBegin,
          iEnd,
          hdColors)
   }
    }


```

Then the last column, the boxplot column, is plotted. 
```{r Ch10-boxplot, eval=F}
# Plot Pupil Size
  if (sum(panel.types == "boxplot") >= 1){

    bplot = which(panel.types == "boxplot")

    for (i in 1:length(bplot)){
    m.boxplot(dat = columns.att[bplot[i]]$boxplot$panel.data,
    posterdat = posterdat.all,
    panel.num = columns.att[bplot[i]]$boxplot$col.num,
    text.size = columns.att[bplot[i]]$boxplot$text.size,
    axis.ticks = columns.att[bplot[i]]$boxplot$axis.ticks,
    axis.labels = columns.att[bplot[i]]$boxplot$axis.labels,
    panels,
    title = columns.att[bplot[i]]$boxplot$header,
    nGroups,
    MedianRow,
    iBegin,
    iEnd,
    hdColors)
    }
}
```

```{r Ch10-boxplot-cum, echo=F, fig.cap = 'Add a boxplot column.'}
  if (sum(panel.types == "poster") >= 1){

    posters = which(panel.types == "poster")

    for (i in 1:length(posters)){

  microposters(panel.col = columns.att[posters[i]]$poster$col.num,
               cumulate = columns.att[posters[i]]$poster$cumulate,
               posterdat = posterdat,
               stateVBorders,
               nationVBorders,
               poster,
               panels,
               nGroups,
               rows,
               MedianRow,
               iBegin,
               iEnd,
               hdColors)

    }
  }
  

  # Plot labels____________________________________________________________

  if (sum(panel.types == "legend") >= 1){

    legends = which(panel.types == "legend")

    for (i in 1:length(legends)){

  m.labels(panel.col = columns.att[legends[i]]$legend$col.num,
           title = columns.att[legends[i]]$legend$header,
           header.size = columns.att[legends[i]]$legend$header.size,
           cex = columns.att[legends[i]]$legend$text.size,
           dcex = columns.att[legends[i]]$legend$point.size,
           font = columns.att[legends[i]]$legend$text.font,
           posterdat = posterdat,
           stateVBorders,
           nationVBorders,
           panels,
           nGroups,
           MedianRow,
           iBegin,
           iEnd,
           hdColors)

    }
  }

  # Plot percent of visits___________________________________
  if (sum(panel.types == "dot") >= 1){

   dots = which(panel.types == "dot")

   for (i in 1:length(dots)){

   m.dotplot(var = columns.att[dots[i]]$dot$panel.data,
          posterdat,
          panel.num = columns.att[dots[i]]$dot$col.num,
          title = columns.att[dots[i]]$dot$header,
          cex = columns.att[dots[i]]$dot$text.size,
          dcex = columns.att[dots[i]]$dot$point.size,
          axis.ticks = columns.att[dots[i]]$dot$axis.ticks,
          axis.labels = columns.att[dots[i]]$dot$axis.labels,
          panels,
          nGroups,
          MedianRow,
          iBegin,
          iEnd,
          hdColors)
   }
    }

# Plot Pupil Size
  if (sum(panel.types == "boxplot") >= 1){

    bplot = which(panel.types == "boxplot")

    for (i in 1:length(bplot)){
    m.boxplot(dat = columns.att[bplot[i]]$boxplot$panel.data,
    posterdat = posterdat.all,
    panel.num = columns.att[bplot[i]]$boxplot$col.num,
    text.size = columns.att[bplot[i]]$boxplot$text.size,
    axis.ticks = columns.att[bplot[i]]$boxplot$axis.ticks,
    axis.labels = columns.att[bplot[i]]$boxplot$axis.labels,
    panels,
    title = columns.att[bplot[i]]$boxplot$header,
    nGroups,
    MedianRow,
    iBegin,
    iEnd,
    hdColors)
    }
}
```


10. **Add title.**
So far, all the columns in the linked microposter plot are created, the plot can be finished up by adding the main title.  


```{r Ch10-title-cum, echo=F, fig.cap = 'Add figure main title.'}
  if (sum(panel.types == "poster") >= 1){

    posters = which(panel.types == "poster")

    for (i in 1:length(posters)){

  microposters(panel.col = columns.att[posters[i]]$poster$col.num,
               cumulate = columns.att[posters[i]]$poster$cumulate,
               posterdat = posterdat,
               stateVBorders,
               nationVBorders,
               poster,
               panels,
               nGroups,
               rows,
               MedianRow,
               iBegin,
               iEnd,
               hdColors)

    }
  }
  

  # Plot labels____________________________________________________________

  if (sum(panel.types == "legend") >= 1){

    legends = which(panel.types == "legend")

    for (i in 1:length(legends)){

  m.labels(panel.col = columns.att[legends[i]]$legend$col.num,
           title = columns.att[legends[i]]$legend$header,
           header.size = columns.att[legends[i]]$legend$header.size,
           cex = columns.att[legends[i]]$legend$text.size,
           dcex = columns.att[legends[i]]$legend$point.size,
           font = columns.att[legends[i]]$legend$text.font,
           posterdat = posterdat,
           stateVBorders,
           nationVBorders,
           panels,
           nGroups,
           MedianRow,
           iBegin,
           iEnd,
           hdColors)

    }
  }

  # Plot percent of visits___________________________________
  if (sum(panel.types == "dot") >= 1){

   dots = which(panel.types == "dot")

   for (i in 1:length(dots)){

   m.dotplot(var = columns.att[dots[i]]$dot$panel.data,
          posterdat,
          panel.num = columns.att[dots[i]]$dot$col.num,
          title = columns.att[dots[i]]$dot$header,
          cex = columns.att[dots[i]]$dot$text.size,
          dcex = columns.att[dots[i]]$dot$point.size,
          axis.ticks = columns.att[dots[i]]$dot$axis.ticks,
          axis.labels = columns.att[dots[i]]$dot$axis.labels,
          panels,
          nGroups,
          MedianRow,
          iBegin,
          iEnd,
          hdColors)
   }
    }

# Plot Pupil Size
  if (sum(panel.types == "boxplot") >= 1){

    bplot = which(panel.types == "boxplot")

    for (i in 1:length(bplot)){
    m.boxplot(dat = columns.att[bplot[i]]$boxplot$panel.data,
    posterdat = posterdat.all,
    panel.num = columns.att[bplot[i]]$boxplot$col.num,
    text.size = columns.att[bplot[i]]$boxplot$text.size,
    axis.ticks = columns.att[bplot[i]]$boxplot$axis.ticks,
    axis.labels = columns.att[bplot[i]]$boxplot$axis.labels,
    panels,
    title = columns.att[bplot[i]]$boxplot$header,
    nGroups,
    MedianRow,
    iBegin,
    iEnd,
    hdColors)
    }
  }

main.title = "Eye Tracking: Looking at Poster Statistics"
title.cex = 1.08

panelSelect(panels, margin = "top")
invisible(panelScale())
graphics::text(0.5, 0.75, labels = main.title, cex = title.cex)

panelSelect(panels, margin = "bottom")
invisible(panelScale(inches = TRUE))
```


```{r Ch10-title, eval=F}
main.title = "Eye Tracking: Looking at Poster Statistics"
title.cex = 1.08

panelSelect(panels, margin = "top")
invisible(panelScale())
graphics::text(0.5, 0.75, labels = main.title, cex = title.cex)

panelSelect(panels, margin = "bottom")
invisible(panelScale(inches = TRUE))
```


Now we finished creating a non-traditional linked microposter plot with our own data, boundary, images in a different domain compared to the other chapters of the book. When one gets familiar with the steps on how to bring in data, boundary, images, and different plots and map overlays, the above steps and functions can be incorporated into a micromap plot function to simplify the creation of a non-traditional micromap plot.


## Summary and Further Reading {#Ch10-FurtherReading}

Readers can find more plot types in Chapter \@ref(Ch5) and implement to a non-traditional micromap plot similar to how the boxplot and dotplot functions are incorporated in this chapter. To understand more of micromap plot creation basics, please read Chapter \@ref(Ch1), \@ref(Ch2), and \@ref(Ch3).

Further, all the steps demonstrated in this chapter have been put into function _DrawEyeLMPlot_ in the **EyeTrackR**\index{R Packages!EyeTrackR} that is available on Github (https://github.com/ChunyangCLi/EyeTrackR.git). If the user wants to put overlays on the map differently without the polygons, _DrawEyeLTMPlot_ function provides a scanpath microposter plot without predefined AOIs those code he user can refer to, while the non-traditional micromap creation approach is the same as demonstrated in this book chapter. 



\printbibliography[segment=\therefsegment,heading=subbibliography]

