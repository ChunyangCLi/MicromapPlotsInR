# Back to the Roots: Non-traditional Micromaps (for Viewing Patterns of Scientific Posters) {#Ch10}


\chapterauthor{Chunyang Li}


This chapter will demonstrate how to create linked micromap plots\index{Linked micromap plot} from scratch without using any of the existing micromap R packages. This may become necessary when the underlying areas are not supported by any shapefile or other boundary file, e.g., positions on a baseball field or locations of stores in a shopping mall, or when non-standard visualizations are required, e.g., the in-flow or out-flow of a spatial area. This chapter will focus on linked microposter plots,\index{Linked microposter plot} i.e., linked micromap plots\index{Linked micromap plot} where the areas of interest\index{Area of interest} are the main viewing areas of a scientific poster.


## Introduction {#Ch10-Introduction}


Linked micromap plots\index{Linked micromap plot} were first introduced in 1996 to highlight geographic patterns and associations among the variables in a spatial dataset [@OCCP1996;@CaPi1996]. They have been widely used to display geospatially-indexed summary statistics. For some in-depth discussion of linked micromap plots,\index{Linked micromap plot} the reader is referred to @SC2008, @CP2010, @SDWPM2014, @SCMW2017, and additional chapters of this book, in particular Chapters \@ref(Ch1), \@ref(Ch2), and \@ref(Ch3).

According to @CP2010, linked micromap plots\index{Linked micromap plot} can represent any two-dimensional space, not just latitude-longitude on the Earth's surface, such as positions on a baseball field or locations of stores in a shopping mall, or the in-flow or out-flow of a spatial area, etc. Based on this idea, @LiSy2016ASA proposed a linked microposter plot\index{Linked microposter plot} to visualize eye tracking data of how people look at scientific posters, considering a poster as a map and the areas of interest\index{Area of interest} (AOIs)\index{AOI|see {Area of interest}} of the poster as the different countries or states. Linked microposter plots\index{Linked microposter plot} are able to more effectively presenting eye tracking data compared to the commonly used eye tracking visualizations. @LiSy2017ASA proposed **EyeTrackR**\index{R Packages!EyeTrackR}, an R package for eye tracking data visualizations including linked microposter plots,\index{Linked microposter plot} and @SLZSM2017ASA applied this R package to create linked microposter plots\index{Linked microposter plot} to visualize how people look at posters of yoga postures.

The following sections will illustrate how to create linked micromap plots\index{Linked micromap plot} from scratch using the creation of linked microposter plots\index{Linked microposter plot} as an example. The goal is to help users to be able to change the R code from this chapter to create other types of linked micromap plots\index{Linked micromap plot} for their own needs. 
<!-- The creation of linked microposter is based on the raw code from @LiSy2017ASA before compiling the R package. -->


## Main {#Ch10-Main}


### Data Processing and Preparation {#Ch10-Data}

<!-- TODO capitalize every word in title and label them -->
#### Eye Tracking Data {#Ch10-Eye-Tracking-Data}

Eye tracking data is obtained from measuring where people are looking at with an eye tracking device, either a mobile eye tracker or a static eye tracker. Static eye trackers are based on a desktop, hence they are often used to study eye motion on a computer screen. Mobile eye trackers are fixed on a user's head, so they are not limited within a restricted area and can be used for a variety of activities, such as playing soccer, driving, etc. The example data we use to demonstrate are from a 30 Hz mobile eye tracker that records 30 images per second. The two co-authors of @LiSy2017ASA looked at a series of statistical and other scientific posters. The original data is a video record indicating where people are looking at. The video data is processed with Matlab and we are able to obtain a dataframe with x and y coordinates transformed to the same coordinate system in terms of the poster we defined. The details of processing the raw video data is described in @Li2017. Time series pupil radius data are also obtained from the eye tracker.

The eye tracking data for the poster we use to demonstrate here is based on a controlled experiment where the participant was given instructions to look at the poster in a certain way. 


#### Shapefile Preparation: AOI Definition {#Ch10-Shapefile}


The shapefile for the linked microposter plot\index{Linked microposter plot} contains the boundaries of the areas of interest\index{Area of interest} for the poster, such as the title, logos, multiple text areas, images, and tables. 

<!-- The AOIs of the posters can be automatically defined with the \textit{DrawAOIs} function in **EyeTrackR**\index{R Packages!EyeTrackR} R package.  -->
The rectangles that represent the AOIs\index{Area of interest} are drawn by mouse clicking two vertices using the `locator()` function in base R graphics [@RCore2017], which is able to return coordinates with the mouse click. The AOIs\index{Area of interest} are named by the analyst.
<!-- The \textit{DrawAOIs} function used __locator__ function in base R graphics [@RCore2017], which is able to return coordinates with the mouse click.  -->
Based on the coordinates of two vertices, we are able to create the boundaries of a rectangle that are used as shapefile of the map. Table \@ref(tab:Ch10-aoi-data) shows two of the AOIs\index{Area of interest} definitions considered as the shapefile for the poster and will be used for the linked microposter plot\index{Linked microposter plot} creation. 
<!-- The code for **EyeTrackR**\index{R Packages!EyeTrackR} R package is available on Github (https://github.com/ChunyangCLi/EyeTrackR.git). -->

The user can create self-defined shapefile based on their own needs, for example, defining different locations of the stores or spots in a baseball field. The output similar to the AOIs\index{Area of interest} from Table \@ref(tab:Ch10-aoi-data) can be directly used to generate the linked micromap plot,\index{Linked micromap plot} which contains the names of the AOIs\index{Area of interest} and the x, y coordinates of the vertices of the AOIs.\index{Area of interest} The coordinates start with one vertex and end with the coordinates of the same vertex. Each AOI\index{Area of interest} is separated by a line with "NA"s. 
According to @CP2010 and @PMWOK2015JSS, "the polygons displayed in the maps of micromaps only need to be detailed enough to convey shape and relative position of the areas and provide a spatial framework by identifying neighboring polygons". 
<!-- If the polygons one is interested to create are all rectangles, the _DrawAOIs_ function from base R can be used to extract the point coordinate in order to create the shape file.  -->
<!-- Here is the code we used to create poster shape files for eye tracking data. -->
Twelve AOIs\index{Area of interest} are defined on the poster image and the shape data is saved as ``AOIName.rda''.


```{r Ch10-aoi-data, eval = TRUE, echo = FALSE}
region_name <- read.csv("data/Ch10/RegionName.csv")
# load(file = "fig_10/RegionName.RData")

knitr::kable(
  region_name,
  caption = "An example of a shapefile for a linked microposter plot.",
  booktabs = TRUE
)
```


Figure \@ref(fig:Ch10-poster-AOI) shows the twelve defined AOIs\index{Area of interest} of the poster. The red bounding boxes outline the defined AOIs.\index{Area of interest} An additional AOI,\index{Area of interest} called ``Blank'', contains all the empty space between these main AOIs,\index{Area of interest} so that the entire poster is covered. The poster is used to test the data processing results and the validity of the linked microposter plot.\index{Linked microposter plot} The participant is timed to look at eight of the AOIs\index{Area of interest} for about six seconds and at four of the AOIs\index{Area of interest} for about two seconds.  Overall, the participants looked at Poster 1 for about 56 seconds resulting in a total of 1680 video frames, so there will be around 1680 rows of x and y coordinates after the video processing. 


```{r Ch10-poster-AOI, fig.cap = 'Poster with defined AOIs.\\index{Area of interest}', out.width = '90%', eval = TRUE, echo = FALSE}
options(knitr.graphics.auto_pdf = TRUE)
knitr::include_graphics("img/Ch10-AOI_boxes.pdf")
```


#### Eye Tracking Data Feature Extractions {#Ch10-Feature-Extractions}


The processed video data is still considered raw eye tracking data, which is a time series of x and y coordinates. To create a linked micromap plot,\index{Linked micromap plot} the data features should be extracted based on the defined Region of Interests or AOIs.\index{Area of interest} Different features of eye tracking data are extracted in terms of the defined AOIs,\index{Area of interest} such as how long the participant has spent and how many times the participant has visited each AOI,\index{Area of interest} eye movement speed from one focus point to another in pixels within each AOIs\index{Area of interest} and pupil radiuses for each visit at the corresponding AOI.\index{Area of interest} 

The resulting datasets described in the above sections are provided to create a sample linked micromap plot\index{Linked micromap plot} or linked microposter plot:\index{Linked microposter plot} `AOIName`\index{Datasets!AOIName} is the shapefile; `locations_testing`\index{Datasets!locations\_testing} is the time series of the x and y coordinates indicating where the participant is looking at on the poster; `poster_dataset_all`\index{Datasets!poster\_dataset\_all} is the list with features extracted from *locations_testing* dataset. `poster_dataset_all` contains three lists: 1. A dataframe with three columns: _section_ (AOI names), _visits\_len_ or time the participant spent on each AOI\index{Area of interest} (in seconds), and _visits\_num_ indicating how many times the participant has visited each AOI.\index{Area of interest} 2. A list of eye movement speed for each AOIs\index{Area of interest} (each AOI\index{Area of interest} is a list). 3. A list of pupil radius for each AOIs\index{Area of interest} (each AOI\index{Area of interest} is a list). 


### Linked Microposter Plot Creation {#Ch10-Linked-Microposter-Creation}


After the eye tracking video data has been processed and AOI\index{Area of interest} shapefile has been created, we can now start to create linked microposter plots\index{Linked microposter plot} following the steps below. 

1. **Panel Design Specification.**
    
First, the user needs to figure out a few questions: What panels are there in the plot? i.e. how many and what variables does one want to visualize? What are the plot types one wants to use for the visualization? How to arrange the panels, such as which panel goes left and which panel goes right? How does one want to label the panels? 

A vector of panel plot types are created to store the designed panel types (code section 1.1). Then in code section 1.2, a list of column attributes are created to specify the order of the panels from left to right using a *col_num*. For the poster panel in 1.2.1, *cumulate* is an attribute that determines if one wants cumulative pattern or not. For each panel, one needs to specify the header of the panel, and the font of the labeling. For the data panels 1.2.3-1.2.5, the data needs to be specified, such as "visits_num", "visits_len", and "pupil_data". Below is the code how the linked microposter plot\index{Linked microposter plot} panels are specified. Here we are creating three data panels: two dot plot panels representing number of visits (1.2.3) and length of visits (1.2.4), and one boxplot panel (1.2.5) representing pupil data. The poster, legend and the data panels are presented from left to right. After the panel types and attributes are specified, a quick check is conducted to make sure that all the panel types one plans to plot are specified (1.3). 


```{r Ch10-panel-design}
# 1.1 Specify panel types
panel_types <- c("poster", "legend", "dot", "dot", "boxplot")

# 1.2 Specify column attributes
columns_att <- list(
  # 1.2.1 Microposter column
  list(
    col_num = 1,
    cumulate = TRUE
  ),
  # 1.2.2 Label column
  list(
    col_num = 2,
    header = "Areas of Interest",
    header_size = 0.7,
    point_size = 0.96,
    text_size = 0.7,
    text_font = 1
  ),
  # 1.2.3 Dot plot column to visualize number of visits
  list(
    col_num = 3,
    panel_data = "visits_num",
    header = "Number of Visits",
    text_size = 0.7,
    point_size = 0.96,
    axis_ticks = NA,
    axis_labels = NA
  ),
  # 1.2.4 Dot plot column to visualize length of visits
  list(
    col_num = 4,
    panel_data = "visits_len",
    header = "Length of Visits (sec)",
    text_size = 0.7,
    point_size = 0.96,
    axis_ticks = NA,
    axis_labels = NA
  ),
  # 1.2.5 boxplot column to visualize pupil radius
  list(
    col_num = 5,
    panel_data = "pupil_data",
    header = "Pupil Radius in Pixels",
    text_size = 0.7,
    axis_ticks = NA,
    axis_labels = NA
  )
)

# 1.3 Check if the length of panel types and column attributes match
columns <- length(columns_att)
if (length(panel_types) < columns) {
  warning("Panel types are not completely specified.")
}
```


2. **Load Images and Data.**

After specifying the panels, the image/poster and data need to be loaded. The poster image is changed to grayscale. We used **imager**\index{R Packages!imager} R package for the poster image processing such as changing the colored poster to grayscale in order to lay other colors on top of it. The user can replace poster with other images and replace eye tracking data with other data types. 


```{r Ch10-load-data}
library(imager)
# 2.1 Load data
load(file = "data/Ch10/posterdat.all.rda")
poster_loc <- "img/Ch10-poster_colored.jpg"
names(posterdat.all[[1]]) <- c("section", "visits_len", "visits_num")
poster_dataset <- posterdat.all[[1]]
names(columns_att) <- panel_types
# 2.2 Load image and convert to gray scale
poster <- imager::load.image(poster_loc)
poster <- imager::grayscale(poster)
```


3. **Load Shapefile for Poster.**

The shape file, i.e. the definitions of AOIs'\index{Area of interest} data, is loaded in 3.1. The AOIs\index{Area of interest} are like states for the map of the united states and the poster is like the nation. The boarders for the entire poster is also defined as a dataframe for the plotting. The AOI\index{Area of interest} "Blank" is added to the shape file with its vertices defined as 0s in 3.2. A polygon for the entire poster is created in 3.3 after the creation and loading the polygons for all the AOIs.\index{Area of interest}


```{r Ch10-load-shapefile}
# 3.1 Load shape file or definitions of AOIs
load("data/Ch10/AOIName.rda")
aoi_vis_borders <- AOIName

# 3.2 Create shape data for blank and add it to poster shapefile
blank <- as.data.frame(matrix(c(rep(0, 5 * 3), NA, NA, NA),
  nrow = 6,
  ncol = 3,
  byrow = TRUE
))
blank[, 1] <- "Blank"
colnames(blank) <- colnames(aoi_vis_borders)
aoi_vis_borders <- rbind(aoi_vis_borders, blank)

# 3.3 Create the polygon for the entire poster
poster_vis_borders <- matrix(
  c(
    0, 0,
    imager::width(poster), 0,
    imager::width(poster),
    imager::height(poster),
    0, imager::height(poster),
    0, 0
  ),
  nrow = 5,
  ncol = 2,
  byrow = TRUE
)
poster_vis_borders <- as.data.frame(poster_vis_borders)
colnames(poster_vis_borders) <- c("x", "y")
```


4. **Sort Rows According to Data Columns.**

The user can specify how they want the rows to be ordered in 4.1, i.e., which column to sort by. In this case, one can choose a variable from the three variables we visualize: number of visits (_visits\_num_), length of visits (_visits\_len_) or pupil radiuses (_pupil\_data_) to sort by. The code for rearranging the datasets sorted by specific columns is in code section 4.2. It is executed using if statements based on the different data structures of the variables. The variable _visits\_len_ is chosen to sort the rows for the plot as an example. 


```{r Ch10-sort-rows}
# 4.1 Specify which column to sortby
sortby <- "visits_len"
decreasing <- TRUE
pupil_data <- poster_dataset[[3]]
# 4.2 Order rows: rearrange the datasets by a specific variable
# 4.2.1 Order by pupil radius
if (sortby == "pupil_data") {
  unordered_median <- unlist(lapply(pupil_data, stats::median))
  ordered_median <- order(unordered_median,
    decreasing = decreasing
  )
  pupil_data <- pupil_data[ordered_median]
  poster_dataset <- poster_dataset[ordered_median, ]
  # 4.2.2 Order by eye movement speed
} else if (sortby == "speed") {
  unordered_median <- unlist(lapply(speed, stats::median))
  ordered_median <- order(unordered_median,
    decreasing = decreasing
  )
  speed <- speed[ordered_median]
  poster_dataset <- poster_dataset[ordered_median, ]
} else {
  # 4.2.3 Order by other variables,
  # such as number of visits and length of visits
  ordered_rows <- order(poster_dataset[, sortby])
  poster_dataset <- poster_dataset[ordered_rows, ]
  pupil_data <- pupil_data[ordered_rows]
}
```


5. **Determine Panel Layouts.**

The quickest approach is to use automatic layout and choose different partitioning described in @PMWOK2015JSS, here we chose the automatic layout and set the partitioning to be 1 (the first partitioning way defined in the function `ArrangePanels()`). The user can also specify layout of the rows, and if median row is wanted or not. Then the sizes of the each rows are calculated based on the overall plot size and the number of rows for the aesthetics of the plot. The code for the functions `panelLayout()`, `DetermineMedianRow()`, and `ArrangePanels()` is in the SharedFunctions.R file provided with the book. There is no need to make changes to these functions, unless more changes on the layout are desired. A layout details list is defined in code section 5.4 for the graphical parameters. 

```{r Ch10-panel-layout}
# 5.1 Load source code for panel definitions and layouts
source("R/Ch10_SharedFunctions.R")
# aoi_names <- row.names(poster_dataset)
layout <- NA
median_row <- TRUE
automatic_layout <- TRUE
partitioning <- 1

# 5.2 Determine the layouts
if (automatic_layout) {
  rows <- ArrangePanels(
    posterdat = poster_dataset,
    partitioning = partitioning
  )[[3]]

  median_row <- DetermineMedianRow(nrow(poster_dataset),
    partitioning = partitioning
  )
} else {
  rows <- length(layout)
  if (length(color_scheme) < max(layout)) {
    color_scheme <- rep(
      color_scheme,
      ceiling(max(layout) / length(color_scheme))
    )

    warning("There are too few colors provided.")
  }
}

if (!automatic_layout && median_row) {
  if ((rows %% 2 == 0) || (layout[ceiling(length(layout) / 2)] != 1)) {
    median_row <- FALSE
    warning("There is no median row.")
  }
}

# 5.3 Determine the plot size of the rows
if (!median_row) {
  rowsize <- rep(17.2 / rows, rows)
} else {
  rowsize <- c(
    rep(17.2 / rows, floor(rows / 2)), 17.2 / (rows * 3.2),
    rep(17.2 / rows, floor(rows / 2))
  )
}


# 5.4 Define some graphic parameters
details <- list(
  bot = 0.77, # bottom margin for the panel
  top = 0.85, # top margin for the panel
  left = 0, # left margin for the panel
  right = 0, # right margin for the panel
  dcex = 0.96, # text size option 1
  tCex = 1.08, # text size 2
  cex = 0.7, # text size option 3
  fontsize = 12, # font size option 1
  font = 1, # font size ooption 2
  line1 = 0.2, # on which margin line, starting at 0 counting outwards.
  line2 = 1.0, # same as above
  line3 = 0.2, # same as above
  ypad = 0.65, # change the scale of the panel vertically
  nameShift = 0.12, # label location shift
  wyellow = rgb(1, 1, 0.82), # color option 1 (for plot background)
  wgray = rgb(0.945, 0.945, 0.945) # color option 2 (for panel background)
)
```


6. **Create Panel Layouts and Plot Indexes.**

_Details_ is a list structure that contains the variables and values for the detailed layout of the plot. `ArrangePanels()` function is able to automatically determine the start and end rows for each plot groups given the input: _row\_begin_ and _row\_end_. The data is arranged into 3 perceptual groups. 

```{r Ch10-panel-layout-and-plot-indexes}
# 6.1 Determine panel layouts
panel_width <- c(2.9, 2.9, 2.9, 2.9, 2.9)
panels <- panelLayout(
  nrow = rows,
  ncol = columns,
  topMargin = details$top,
  bottomMargin = details$bot - 0.7,
  leftMargin = details$left,
  rightMargin = details$right,
  rowSep = rep(0.01, rows + 1),
  rowSize = rowsize,
  colSize = panel_width,
  colSep = rep(0.1, (columns + 1)) # space between panels
)
# 6.2 Set panel row indices
row_begin <- ArrangePanels(
  posterdat = poster_dataset,
  partitioning = partitioning,
  AutomaticLayout = automatic_layout,
  Layout = layout,
  MedianRow = median_row
)[[1]]
row_end <- ArrangePanels(
  posterdat = poster_dataset,
  partitioning = partitioning,
  AutomaticLayout = automatic_layout,
  Layout = layout,
  MedianRow = median_row
)[[2]]
n_groups <- length(row_end)
```


7. **Plot Posters.**

After all the settings are specified, we can now start to create the linked microposter plot\index{Linked microposter plot} one column at a time, by starting from the leftmost column, i.e., the microposters. The linked microposter plots\index{Linked microposter plot} code is structured similar to the `mmplot()` function provided in the **micromap**\index{R Packages!micromap} R package by @PaOl2015.     

A `plot_microposters()` function is created to plot the poster column. If the user keep the similar data structure as the eye tracking data demonstrated, dataframe, column names, and image types, then there is no need to adjust this function to visualize other topic of interest, otherwise, one will need to adjust the data and column names accordingly. 

The microposter column with small posters is plotted with highlights according to the context and labels. `panel_col` is the column number of this panel that is defined with the column attributes, the rest of the inputs are the attributes also specified in the above sections. First, the labels are specified in 7.1 and 7.2. One can adjust the texts inside the function. Then the microposters with specific highlights are created by the perceptual groups divided with a for loop in the code 7.3. In this example, there are 3 perceptual groups and no median row. For each group, we color the AOIs\index{Area of interest} presented in the group, the rest AOIs\index{Area of interest} are either gray as background or colored in light yellow if they have been presented in the previous groups given that cumulative option is True. The borders of each AOIs\index{Area of interest} and the entire poster are plotted with thick black lines. Within the `plot_microposters()` function, the explanations of the most important variables are listed below: 

* `gsubs`: the row index for current group;
* `back`: the row index for the AOIs\index{Area of interest} that are not presenting in the current group;
* `fore`: the complement of `back`, i.e., the row index for the AOIs that are presenting in the current group;
* `pen`: the index to determine which color to use in the selected color scheme `color_scheme`.
* `past`: index for cumulative AOIs\index{Area of interest} shown above. 

The panels and indices are set in code section 7.3.1, 7.3.2, and 7.3.5. Then posters (7.3.3) and `back` AOIs\index{Area of interest} (7.3.4) are plotted. 7.3.6 and 7.3.7 plotted the `fore` AOIs.\index{Area of interest} The microposters are finished with coloring the cumulative sections in 7.3.8 and plotting the outlines or the borders for the poster.


```{r Ch10-create-microposters-function}
plot_microposters <- function(panel_col,
                              cumulate = TRUE,
                              poster_dataset,
                              aoi_vis_borders,
                              poster_vis_borders,
                              poster,
                              panels,
                              n_groups,
                              rows,
                              median_row,
                              row_begin,
                              row_end,
                              color_scheme) {
  # 7.1 Assign aoi ids (one per aoi)
  aoi_ids <- aoi_vis_borders$section[is.na(aoi_vis_borders$x)]

  # 7.2 Plot panel titles
  panelSelect(panels, 1, panel_col)
  panelScale()
  # If there is Median row,
  # then there will be additional labels and a median panel plotted;
  # if not, it will be skipped.
  if (median_row) {
    graphics::mtext(
      side = 3,
      line = details$line1,
      "Above Median Visits",
      cex = details$cex
    )

    if (cumulate) {
      graphics::mtext(
        side = 3,
        line = details$line2,
        "Cumulative Microposters",
        cex = details$cex
      )
    }
  } else {
    if (cumulate) {
      graphics::mtext(
        side = 3,
        line = details$line1,
        "Cumulative Microposters",
        cex = details$cex
      )
    }
  }

  panelSelect(layout = panels, i = n_groups, j = panel_col)
  panelScale()

  if (median_row) {
    graphics::mtext(
      side = 1,
      line = details$line3,
      "Below Median Visits",
      cex = details$cex
    )
  }

  rxpoly <- range(poster_vis_borders$x, na.rm = TRUE)
  rypoly <- range(poster_vis_borders$y, na.rm = TRUE)

  # 7.3 Plot by perceptual groups
  for (i in 1:n_groups) {
    if (median_row && i == ceiling(n_groups / 2)) {
      # 7.3.1 Map not drawn, median region plotted in adjacent panel
      panelSelect(panels, (n_groups + 1) / 2, panel_col)
      panelScale()
      panelFill(col = details$wgray)
      panelOutline(col = "black")
      graphics::text(0.5, 0.55, "Median", cex = details$cex)
      next
    }

    # 7.3.2 Select panels and set indexes
    panelSelect(panels, i, panel_col)
    panelScale(rxpoly, rypoly)
    gsubs <- row_begin[i]:row_end[i]
    median_group <- row_begin[ceiling(n_groups / 2)]
    # If there is median row, include median row in the index
    if (median_row) {
      if (i == ceiling(n_groups / 2) - 1) {
        gsubs <- c(gsubs, median_group)
      }

      if (i == ceiling(n_groups / 2) + 1) {
        gsubs <- c(gsubs, median_group)
      }
    }

    panel_names <- poster_dataset$section[gsubs]

    # 7.3.3 Plot background images (the poster)
    graphics::rasterImage(
      poster,
      0,
      0,
      imager::width(poster),
      imager::height(poster)
    )

    # 7.3.4 Plot background (out of contour) regions
    # in gray with white outlines
    # "front_regions" are the regions in the group, the rest are "back"
    front_regions <- poster_dataset$section[1:row_end[i]]
    back <- is.na(match(aoi_vis_borders$section, front_regions))
    graphics::polygon(aoi_vis_borders$x[back],
      aoi_vis_borders$y[back],
      border = TRUE
    )

    # 7.3.5 Set the indices: plot foreground regions
    # for the panel in their special colors pens 1:5
    # and other in contour regions in light yellow if cumulative is True
    fore <- !is.na(match(aoi_vis_borders$section, panel_names))
    pen <- match(aoi_ids,
      panel_names,
      nomatch = 10
    )[!is.na(match(aoi_ids, panel_names))]

    # 7.3.6 Outline regions
    # If there is a median row,
    # then the median row color is defined here
    if (median_row) {
      pen[which(pen == median_group)] <- length(color_scheme)
    }
    graphics::polygon(aoi_vis_borders$x[fore],
      aoi_vis_borders$y[fore],
      col = scales::alpha(color_scheme[pen], 0.7),
      border = FALSE
    )

    # 7.3.7 Plot borders
    graphics::polygon(aoi_vis_borders$x[fore],
      aoi_vis_borders$y[fore],
      col = "black",
      density = 0,
      lwd = 1
    )

    # 7.3.8 Plot and color cumulative regions if it is defined to be True
    if (cumulate) {
      past <- !back & !fore
      graphics::polygon(aoi_vis_borders$x[past],
        aoi_vis_borders$y[past],
        col = scales::alpha(details$wyellow, 0.7),
        border = FALSE
      )
      graphics::polygon(aoi_vis_borders$x[past],
        aoi_vis_borders$y[past],
        col = "black",
        density = 0,
        lwd = 1
      )
    }

    # 7.3.9 plot poster outline
    graphics::polygon(poster_vis_borders$x,
      poster_vis_borders$y,
      col = "black",
      density = 0,
      lwd = 1
    )
  }
}
```

Now we can apply the `plot_microposters()` function to create our first column in the linked microposter plot,\index{Linked microposter plot} i.e., the microposter column. The color palette is selected from the **RColorBrewer**\index{R Packages!RColorBrewer} R package. In this example, five colors are used from the `Paired` color palette, since we have five rows at most for each perceptual group. Multiple microposter columns could be created if needed.

```{r Ch10-create-microposters, fig.cap = 'Linked microposters plot poster column.', fig.width = 7}
color_scheme <- rev(RColorBrewer::brewer.pal(5, "Paired"))
if (sum(panel_types == "poster") >= 1) {
  posters <- which(panel_types == "poster")

  for (i in 1:length(posters)) {
    plot_microposters(
      panel_col = columns_att[posters[i]]$poster$col_num,
      cumulate = columns_att[posters[i]]$poster$cumulate,
      poster_dataset = poster_dataset,
      aoi_vis_borders = aoi_vis_borders,
      poster_vis_borders = poster_vis_borders,
      poster = poster,
      panels = panels,
      n_groups = n_groups,
      rows = rows,
      median_row = median_row,
      row_begin = row_begin,
      row_end = row_end,
      color_scheme = color_scheme
    )
  }
}
```


8. **Plot Labels.**

After plotting the poster image column, we can plot the labels or the legends. Similarly, we created a function `plot_labels()` to make the plotting process cleaner and easier to reuse. The function is structured similarly as the `plot_microposters()` function, also the variable naming schemes. First, we define the label content and aesthetics such as font and size. The panels and indices are set in 8.1 and 8.2. Then we create the labels with a for-loop in the code based on the perceptual groups in code section 8.3. Within each perceptual group, the colors of the labels are set to match the corresponding AOIs\index{Area of interest} by using the same color scheme and plotting order. The `Blank` AOI\index{Area of interest} is defined separately as we want it to be white color, which is not in the color series we chose (code section 8.3.3). 

```{r Ch10-create-labels-function}
plot_labels <- function(panel_col,
                        title,
                        header_size = 0.7,
                        cex = 0.7,
                        dcex = 0.96,
                        font = 1,
                        poster_dataset,
                        aoi_vis_borders,
                        poster_vis_borders,
                        panels,
                        n_groups,
                        median_row,
                        row_begin,
                        row_end,
                        color_scheme) {
  # 8.1 Define panels
  panelSelect(panels, 1, panel_col)
  panelScale()

  # 8.2 Plot median row panel is there is a median
  if (median_row) {
    graphics::mtext(
      side = 3,
      line = details$line2,
      title,
      cex = header_size
    )
  } else {
    graphics::mtext(
      side = 3,
      line = details$line1,
      title,
      cex = header_size
    )
  }

  # 8.3 Plot labels by perceptual groups
  for (i in 1:n_groups) {
    # 8.3.1 Set indices and panels
    gsubs <- row_begin[i]:row_end[i]
    gnams <- poster_dataset$section[gsubs]
    nsubs <- length(gnams)
    pen <- 1:nsubs
    laby <- nsubs:1
    panelSelect(panels, i, panel_col)
    panelScale(c(0, 1), c(1 - details$ypad, nsubs + details$ypad))

    # 8.3.2 Define the index for median row if there is median
    if (median_row && i == ((n_groups + 1) / 2)) {
      pen <- length(color_scheme)
    }

    # 8.3.3 Plot labels and color them corresponding to
    # the colors of the AOIs in the posters
    for (j in 1:length(pen)) {
      graphics::points(0.1,
        laby[j],
        pch = 16,
        col = color_scheme[pen[j]],
        cex = dcex
      )
      graphics::points(0.1,
        laby[j],
        pch = 1,
        col = "black",
        cex = dcex
      )
      graphics::text(0.18,
        laby[j] + details$nameShift,
        gnams[j],
        cex = cex,
        adj = 0,
        col = "black",
        font = font
      )

      # Label "Blank" AOI separately as white is not in the color scheme
      if (gnams[j] == "Blank") {
        graphics::points(0.1,
          laby[j],
          pch = 16,
          col = "white",
          cex = dcex
        )
        graphics::points(0.1,
          laby[j],
          pch = 1,
          col = "black",
          cex = dcex
        )
      }
    }
  }
}
```

Now the `plot_labels()` function can be executed and the labels and the legends columns can be plotted.

```{r Ch10-plot-labels, eval = FALSE}
if (sum(panel_types == "legend") >= 1) {
  legends <- which(panel_types == "legend")

  for (i in 1:length(legends)) {
    plot_labels(
      panel_col = columns_att[legends[i]]$legend$col_num,
      title = columns_att[legends[i]]$legend$header,
      header_size = columns_att[legends[i]]$legend$header_size,
      cex = columns_att[legends[i]]$legend$text_size,
      dcex = columns_att[legends[i]]$legend$point.size,
      font = columns_att[legends[i]]$legend$text.font,
      poster_dataset = poster_dataset,
      aoi_vis_borders = aoi_vis_borders,
      poster_vis_borders = poster_vis_borders,
      panels = panels,
      n_groups = n_groups,
      median_row = median_row,
      row_begin = row_begin,
      row_end = row_end,
      color_scheme = color_scheme
    )
  }
}
```

```{r Ch10-create-microposters-and-labels, echo = FALSE, fig.cap = 'Similar to Figure \\@ref(fig:Ch10-create-microposters), now with labels added.', fig.width = 7, tidy = FALSE}
<<Ch10-create-microposters>>
<<Ch10-plot-labels>>
```


9. **Other Columns.**

In our case, dotplot and boxplot are presented to visualize the visits and the pupil radiuses as examples. Similar to the `plot_microposters()` and `plot_labels()` functions, we first set up indices, panels, specify labels (axis, axis ticks, and texts) and then plot each dot or boxplot one by one with the corresponding colors within each perceptual group. Since we chose white color for blank, it is coded as a special case. 

For the `plot_dotplot()` function, the axis range as well as the panel grid are automatically determined by the range of the input data in A.9.1, if they are not defined by the user. For the automatic setup, axis range is set to be slightly below the minimum and above the maximum, then the grid in panels are determined by evenly dividing the panel width with the predefined functions. Finally, the dots are plotted manually by perceptual groups using the `points()` fuction and connected with black lines in A.9.3.5, after the indices, panels, and labels are created for each group from A.9.3.1 to A.9.3.4.    

For the `plot_boxplot()` function, the dataframe is specified within the data list in B.9.1, then the plot parameters are defined for the boxplot in B.9.2. The summary statistics of the data by AOIs\index{Area of interest} are summarised for the creation of boxplot in B.9.3. Similar to the `plot_dotplot()`, the panel grid and axis lables are created in B.9.4, and groups panels are set up in B.9.5. Then the boxplots are created by perceptual groups manually by first plotting the outliers, and then the boxes. 


```{r Ch10-dotplot-boxplot-functions}
# A Dotplot
plot_dotplot <- function(var,
                         poster_dataset,
                         panel_num,
                         title,
                         cex = 0.7,
                         dcex = 0.96,
                         axis_ticks = NA,
                         axis_labels = NA,
                         panels,
                         n_groups,
                         median_row,
                         row_begin,
                         row_end,
                         color_scheme) {
  # A.9.1 Define grids based on data to visualize
  var <- poster_dataset[, var]
  aoi_names <- poster_dataset$section
  countRange <- range(var)
  countRange <- mean(countRange) + 1.3 * diff(countRange) * c(-0.5, 0.5)
  if (is.na(axis_ticks)) {
    # Use pretty values that are in bounds
    countGrid <- panelInbounds(countRange)
  } else {
    countGrid <- axis_ticks
  }
  # A.9.2 Set up panels as big frame for the entire plot
  panelSelect(panels, 1, panel_num)
  panelScale()
  graphics::mtext(
    side = 3,
    line = details$line1,
    text = title,
    cex = cex
  )
  # A.9.3 Plot by perceptual groups
  for (i in 1:n_groups) {
    # A.9.3.1 Set up indices
    gsubs <- row_begin[i]:row_end[i] # group subscript
    gnams <- aoi_names[gsubs] # group names
    nsubs <- length(gsubs) # number of group subscripts
    pen <- 1:nsubs # index counts forward
    laby <- nsubs:1 # index counts backward
    # A.9.3.2 Set up group panels
    panelSelect(panels, i, panel_num)
    countRange2 <- c(
      min(countGrid) - mean(countGrid) * 0.28,
      max(countGrid) + mean(countGrid) * 0.28
    )
    panelScale(countRange2, c(1 - details$ypad, nsubs + details$ypad))
    panelFill(col = details$wgray)
    panelGrid(x = countGrid, col = "white")
    panelOutline(col = "white")
    # A.9.3.3 label axis
    if (i == n_groups) {
      # if axis labels are not defined
      if (is.na(axis_labels)) {
        graphics::axis(
          side = 1,
          at = countGrid,
          labels = as.character(countGrid),
          col = "black",
          mgp = c(1, 0, 0),
          tck = -0.04,
          cex.axis = cex
        )
        # if axis labels are defined by the user
      } else {
        graphics::axis(
          side = 1,
          at = countGrid,
          labels = as.character(axis_labels),
          col = "black",
          mgp = c(1, 0, 0),
          tck = -0.04,
          cex.axis = cex
        )
      }
    }
    # A.9.3.4 Define median row index if there is a median row
    if (median_row & i == ((n_groups + 1) / 2)) {
      pen <- length(color_scheme)
    }
    graphics::lines(var[gsubs], laby, col = "black", lwd = 1)
    # A.9.3.5 Plot dots using corresponding data points
    for (j in 1:length(pen)) {
      graphics::points(var[gsubs[j]],
        laby[j],
        pch = 16,
        cex = dcex,
        col = color_scheme[pen[j]]
      )
      graphics::points(var[gsubs[j]],
        laby[j],
        pch = 1,
        cex = dcex,
        col = "black"
      )
      if (gnams[j] == "Blank") {
        graphics::points(var[gsubs[j]],
          laby[j],
          pch = 16,
          cex = dcex,
          col = "white"
        )
        graphics::points(var[gsubs[j]],
          laby[j],
          pch = 1,
          cex = dcex,
          col = "black"
        )
      }
    }
  }
}

# B. Boxplot
plot_boxplot <- function(dat,
                         poster_dataset,
                         panel_num,
                         text_size = 0.7,
                         panels,
                         title,
                         axis_ticks = NA,
                         axis_labels = NA,
                         n_groups,
                         median_row,
                         row_begin,
                         row_end,
                         color_scheme) {
  # B.9.1 Prepare data to visualize
  if (dat == "speed") {
    dat <- poster_dataset[[2]]
  } else if (dat == "pupil_data") {
    dat <- poster_dataset[[3]]
  }
  aoi_names <- poster_dataset[[1]]$section

  # B.9.2 Set up box plot parameters
  thin_box <- 0.2
  thick_box <- 0.60
  use_black <- FALSE # for outliners
  median_line <- 0.88
  dot_median_col <- "white"
  pch_median <- 19
  cex_median <- 0.95
  lwd_median <- 2
  col_median <- "white"
  cex_outlier <- 0.6 # see cexDot
  lwd_outlier <- 0.4
  sc <- 1.3
  pad <- 0.67 # y axis padding for integer plotting locates
  lwd_grid <- 1
  # y boxplot scaling
  # standard - horizontal box - no vertical (y) dimensions
  py <- c(-0.5, -0.5, 0.5, 0.5)
  thiny <- thin_box * py
  thicky <- thick_box * py
  medy <- median_line * c(-0.5, 0.5)
  ry <- c(0, 1) # used in y scaling for grid lines

  # B.9.3 Gather stats and put in AOI order
  boxlist <- graphics::boxplot(dat, plot = FALSE)
  # For the moment match on names
  # Boxlist: names, stats, out, group
  # Name: 1-low,2-25%,3-median,4-75%,5-high
  # 5 variables for each state.
  stats <- boxlist$stats
  # a column for each AOI
  # - thin line - outliers - columns in boxlist (1,5,5,1)
  thin <- stats[c(1, 5, 5, 1), ]
  # a column for each AOI - thick line - 25% to 75% -
  # columns in boxlist(2,4,4,2)
  thick <- stats[c(2, 4, 4, 2), ]
  med <- stats[3, ] # a single value for each AOI (median)
  nam <- boxlist$names # AOI names
  # Define outliers
  outlier <- rep(FALSE, length(med))
  if (!is.null(boxlist$out)) {
    out <- boxlist$out
    group <- boxlist$group
    outlier[unique(group)] <- TRUE
  }

  # B.9.4 Put data in order and set up grids
  ord <- match(aoi_names, nam)

  if (is.null(out)) {
    rx <- range(stats)
  } else {
    rx <- range(stats, out)
  }
  countRange <- sc * diff(rx) * c(-0.5, 0.5) + mean(rx)
  # If axis is not defined, grids are determined automatically
  if (is.na(axis_ticks)) {
    # Use pretty values that are in bounds
    countGrid <- panelInbounds(countRange)
    # If axis is defined by user
  } else {
    countGrid <- axis_ticks
  }

  # B.9.5 Set up group panels
  panelSelect(panels, 1, panel_num)
  panelScale()
  graphics::mtext(
    side = 3,
    line = details$line1,
    text = title,
    cex = text_size
  )

  # B.9.6 Plot by perceptual groups
  for (i in 1:n_groups) {
    # B.9.6.1 Set up plotting index
    gsubs <- row_begin[i]:row_end[i]
    nsubs <- length(gsubs)
    gnams <- aoi_names[gsubs]
    pen <- 1:nsubs
    laby <- nsubs:1
    # B.9.6.2 Set up group panels
    panelSelect(panels, i, panel_num)
    countRange2 <- c(
      min(countGrid) - stats::median(countGrid) * 0.05,
      max(countGrid) + stats::median(countGrid) * 0.05
    )
    panelScale(countRange2, c(1 - details$ypad, nsubs + details$ypad))
    panelFill(col = details$wgray)
    panelGrid(x = countGrid, col = "white")
    panelOutline(col = "white")
    # B.9.6.3 Plot axis labels
    # if axis labels are not defined
    if (i == n_groups) {
      if (is.na(axis_labels)) {
        graphics::axis(
          side = 1,
          at = countGrid,
          labels = as.character(countGrid),
          col = "black",
          mgp = c(1, 0, 0),
          tck = -0.04,
          cex.axis = text_size
        )
        # if axis labels are defined by user
      } else {
        graphics::axis(
          side = 1,
          at = countGrid,
          labels = as.character(axis_labels),
          col = "black",
          mgp = c(1, 0, 0),
          tck = -0.04,
          cex.axis = text_size
        )
      }
    }
    # B.9.6.4 Define median row index if there is a median row
    if (median_row && i == ((n_groups + 1) / 2)) {
      pen <- length(color_scheme)
    }

    for (k in 1:length(pen)) {
      # Set up index for each AOI
      m <- ord[gsubs[k]] # m is the location of the AOIs in boxlist
      if (is.na(m)) next
      kp <- pen[k] # color number
      ht <- laby[k]

      # Plot outliers
      # Plot "Blank" AOI separately in white color
      # Plot other AOIs with colors in the selected color scheme
      if (outlier[m]) {
        vals <- out[group == m]
        if (gnams[k] == "Blank") {
          graphics::points(vals, rep(ht, length(vals)),
            pch = 1,
            col = ifelse(use_black, "black", "#FFFFFF"),
            cex = cex_outlier,
            lwd = lwd_outlier
          )
        } else {
          graphics::points(vals, rep(ht, length(vals)),
            pch = 1,
            col = ifelse(use_black, "black", color_scheme[kp]),
            cex = cex_outlier,
            lwd = lwd_outlier
          )
        }
      }
      # Plot box plots
      # Plot "Blank" AOI separately in white color
      # Plot other AOIs with colors in the selected color scheme
      if (gnams[k] == "Blank") {
        graphics::polygon(thin[, m],
          rep(ht, 4) + thiny,
          col = "#FFFFFF",
          border = NA
        )
        graphics::polygon(thick[, m],
          rep(ht, 4) + thicky,
          col = "#FFFFFF",
          border = NA
        )
        graphics::segments(med[m], ht + medy[1], med[m], ht + medy[2],
          col = "black",
          lwd = lwd_median
        )
      } else {
        graphics::polygon(thin[, m],
          rep(ht, 4) + thiny,
          col = color_scheme[kp],
          border = NA
        )
        graphics::polygon(thick[, m],
          rep(ht, 4) + thicky,
          col = color_scheme[kp],
          border = NA
        )
        graphics::segments(med[m], ht + medy[1], med[m], ht + medy[2],
          col = "black",
          lwd = lwd_median
        )
      }
    }
  }
}
```

There are two columns visualized with dotplot: the length of time spent in each AOI\index{Area of interest} and the number of times each AOI\index{Area of interest} is visited. The two columns are plotted by calling the `plot_dotplot()` function twice within the for loop. 

```{r Ch10-add-dotplot, eval = FALSE}
# plot length of visits and number of visits
if (sum(panel_types == "dot") >= 1) {
  dots <- which(panel_types == "dot")

  for (i in 1:length(dots)) {
    plot_dotplot(
      var = columns_att[dots[i]]$dot$panel_data,
      poster_dataset = poster_dataset,
      panel_num = columns_att[dots[i]]$dot$col_num,
      title = columns_att[dots[i]]$dot$header,
      cex = columns_att[dots[i]]$dot$text_size,
      dcex = columns_att[dots[i]]$dot$point_size,
      axis_ticks = columns_att[dots[i]]$dot$axis_ticks,
      axis_labels = columns_att[dots[i]]$dot$axis_labels,
      panels = panels,
      n_groups = n_groups,
      median_row = median_row,
      row_begin = row_begin,
      row_end = row_end,
      color_scheme = color_scheme
    )
  }
}
```

```{r Ch10-dotplot-cum, echo = FALSE, fig.cap = 'Similar to Figure \\@ref(fig:Ch10-create-microposters-and-labels), now with two dotplot columns added.', fig.width = 7, tidy = FALSE}
<<Ch10-create-microposters-and-labels>>
<<Ch10-add-dotplot>>
```

Then the final column, the boxplot column to visualize pupil sizes for each AOIs,\index{Area of interest} is added.

```{r Ch10-add-boxplot, eval = FALSE}
# Plot pupil size
if (sum(panel_types == "boxplot") >= 1) {
  bplot <- which(panel_types == "boxplot")

  for (i in 1:length(bplot)) {
    plot_boxplot(
      dat = columns_att[bplot[i]]$boxplot$panel_data,
      poster_dataset = posterdat.all,
      panel_num = columns_att[bplot[i]]$boxplot$col_num,
      text_size = columns_att[bplot[i]]$boxplot$text_size,
      axis_ticks = columns_att[bplot[i]]$boxplot$axis_ticks,
      axis_labels = columns_att[bplot[i]]$boxplot$axis_labels,
      panels = panels,
      title = columns_att[bplot[i]]$boxplot$header,
      n_groups = n_groups,
      median_row = median_row,
      row_begin = row_begin,
      row_end = row_end,
      color_scheme = color_scheme
    )
  }
}
```

```{r Ch10-dotplot-boxplot-cum, echo = FALSE, fig.cap = 'Similar to Figure \\@ref(fig:Ch10-dotplot-cum), now with one boxplot column added.', fig.width = 7, tidy = FALSE}
<<Ch10-dotplot-cum>>
<<Ch10-add-boxplot>>
```


10. **Add Title.**

By now, all the columns in the linked microposter plot\index{Linked microposter plot} have been created. The plot can now be finalized by adding the main title.  


```{r Ch10-add-title, eval = FALSE}
main.title <- "Eye Tracking: Looking at Poster Statistics"
title.cex <- 1.08

panelSelect(panels, margin = "top")
invisible(panelScale())
graphics::text(0.5, 0.75, labels = main.title, cex = title.cex)

panelSelect(panels, margin = "bottom")
invisible(panelScale(inches = TRUE))
```


```{r Ch10-dotplot-boxplot-title-cum, echo = FALSE, fig.cap = 'Similar to Figure \\@ref(fig:Ch10-dotplot-boxplot-cum), now with the main title added.', tidy = FALSE}
<<Ch10-dotplot-boxplot-cum>>
<<Ch10-add-title>>
```

Now we finished creating a non-traditional linked microposter plot\index{Linked microposter plot} with our own data, boundary, images in a different domain compared to the other chapters of the book. When one gets familiar with the steps on how to bring in data, boundary, images, and different plots and map overlays, the above steps and functions can be incorporated into a linked micromap plot\index{Linked micromap plot} function to simplify the creation of a non-traditional linked micromap plot.\index{Linked micromap plot}


## Summary and Further Reading {#Ch10-FurtherReading}


Readers can find more plot types in Chapter \@ref(Ch5) and implement those for non-traditional linked micromap plots\index{Linked micromap plot} similar to how the boxplot and dotplot functions are incorporated in this chapter. To understand more of linked micromap plot\index{Linked micromap plot} principles and basics of their creation via the **micromap**\index{R Packages!micromap} and **micromapST**\index{R Packages!micromapST} R packages, readers should refer to Chapters \@ref(Ch1), \@ref(Ch2), and \@ref(Ch3).

Further, all steps demonstrated in this chapter have been placed into the function `DrawEyeLMPlot()` in the **EyeTrackR**\index{R Packages!EyeTrackR} R package that is available on GitHub (https://github.com/ChunyangCLi/EyeTrackR.git). If the user wants to put overlays on the poster in a different way without using the AOI\index{Area of interest} polygons, the `DrawEyeLTMPlot()` function provides a linked scanpath microposter plot\index{Linked scanpath microposter plot} [@Li2017] without predefined AOIs.\index{Area of interest} If interested, the user can directly refer to that code on GitHub, while the non-traditional linked micromap plot\index{Linked micromap plot} creation approach from the **EyeTrackR**\index{R Packages!EyeTrackR} R package is the same as demonstrated in this chapter. 


\printbibliography[segment=\therefsegment,heading=subbibliography]
