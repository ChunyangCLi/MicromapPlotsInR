# Linked Micromap Plots for Point Locations {#Ch6}


\chapterauthor{Martin Holdrege, J{\"u}rgen Symanzik}

A few stand-alone attempts have been made in the past to create linked micromap plots 
for point locations such as climate stations and cities, rather than for areal locations 
(i.e., polygons). 
This requires that the point location is extended to a small (circular or quadratic) 
area that can be color-coded in a linked micromap plot. This chapter provides an 
overview of necessary steps to produce linked micromap plots for point locations 
to create areas of suitable sizes and to avoid overplotting of nearby point locations.

## Notes [to be deleted later]

To do:
-consider creating a function that will combine the circles with a background map
(this could be called `create_spatial_points_map()`)


## Introduction: The challenge of displaying point data using micromaps

One main difference when making micromaps for point locations is that the user 
must create polygons to represent the 
point locations. The more standard use of micromaps displays data associated 
likely already exist. In the case of point locations,
points need to displayed on the 
map as a circles (or other shape). The center of the circle is the coordinates of a given point location.
Once the polygons are created, maps and accompanying data can be visualized 
using the  **micromap**\index{R Packages!micromap} [@PaOl2015] package, 
which requires that each entity for which data
is displayed is a polygon on the map.

Specific challenges when creating the polygons (circles) that that are displayed on the 
micromap, is that they
need to be appropriately sized and should not overlap too much. 
Lastly, to create more useful micromaps, the polygons representing the point 
locations then need to be
integrated into a base map that shows geographic
boundaries of interest. 

## Outline of steps that need to be accomplished to create micromaps of point locations

Broadly the following steps need be followed to display point locations
on micromaps.

\begin{enumerate}
   \item Obtain coordinates of the point locations of interest along with 
  the corresponding data.
  \item Obtain geographic data for the underlying base map that the user wishes
  to display.
  \item If needed, adjust the locations points that are close to each other. If
  points are very close together they may almost entirely overlap on the final map,
  making them hard to see.
  \item Polygons (circles, or other shape) need to be created around points. 
  Multiple R packages offer ways to create buffers (polygons), around an objec,
  and the `points2circles()` function provides a convenient wrapper.
  \item The base map and polygons representing point locations need to be 
  combined into single object.
  \item Flatten the combined object created in the previous step into a dataframe 
  that can be used in the `mmplot()` from the
  **micromap** package \index{R Packages!micromap} [@PaOl2015]).
  \item Create micromap.
  \item Iterate until the size of the circles representing point locations
  and their level of overlap is acceptable .
\end{enumerate}

We walk through the steps needed to make micromaps using three separate datasets. 
In section \@ref(Ch6-Example1) we create a micromap of showing
the populations of large cities across Asia. Section \@ref(Ch6-Example2) provides
an example where the locations of point locations are manually adjusted, and section
\@ref(Ch6-Example3) provides an example where point locations are repelled
from each other using the `point_repel()` function. 

## Plot large cities in Asia {#Ch6-Example1}

In this example, we will visualize the locations of the 10 largest cities
in Asia, and their associated populations. 

First the necessary packages need to be loaded. 

```{r message = FALSE, warning=FALSE}
library(micromap)
library(maptools)
library(sf)
library(dplyr)
source("R/Ch6_functions.R")
```


Load the point locations of the cities. 

```{r}
cities <- readRDS("data/Ch6-data/asian_cities.RDS")
```

Convert population, so that the the numbers are more readable in the final
micromap. 

```{r}
cities$population <- cities$population/10^6 
```

Note, that when examining the locations of the cities, none of the 
the cities are very close together, so when we draw circles around the point
locations we won't need to be worried about undo overlap in the final maps. 

```{r}
plot(cities$long, cities$lat, xlab = "Longitude", ylab = 'Latitude')
```


### Generate polygons from points

The next step is to draw polygons (circles) around the points. 


```{r}
circles_sf <- points2circles(cities, coords = c("long", "lat"), 
                             crs = "EPSG:4326")

```

Because this work flow currently relies on `create_map_table`, the 
`sf` objects first converted to a `Spatial` object (from the `sp` package),
before it is then converted into a dataframe for use by micromap.

```{r}
circles_df <- create_map_table(as(circles_sf, 'Spatial'), 
                               IDcolumn = "city")

```

### Create micromap

This first example shows the locations of the cities, but doesn't have a base map.
The next step is join the point locations with a base map. 

```{r Ch6-micromap1, fig.cap = 'Micromap showing the 10 largest cities in asia. Note that locations of cities are shown, but there are no country polygons to indicate the location of cities', fig.width = 4, fig.height = 3}
mmplot(stat.data=cities,
       map.data=circles_df,
        panel.types=c("labels", "dot", "map"),
       panel.data=list("city","population", NA),
       ord.by="population", grouping=5,
       map.link=c("city","ID"))
```

### Combine point locations and background map

To make a better micromap the polygons of the point locations need to be combined
with a background map.

[**NOTE--I'll need to determine what part of this workflow will be put
into functions**]

First we're cropping the world map so that only the region of interest is shown.

**Note this code will need to be updated so that it uses newer tools so it doesn't throw
a warning (e.g., don't use wrld_simpl from maptools and don't rely on raster
package?, see note here: https://cran.r-project.org/web/packages/rgeos/index.html
regarding the fact that `rgeos` is being retired in 2023)**

```{r warning = FALSE, message = FALSE}
data('wrld_simpl')
# note this throws a warning: https://gis.stackexchange.com/questions/379693/crop-wrld-simpl-gives-error-after-r-update
asia <- raster::crop(wrld_simpl, raster::extent(24, 145, 8, 47))

asia_sf <- st_as_sf(asia) # convert to simple feature

```

Note, the circles around
the cities and the underlying map need to have the same projection.


```{r}
asia_sf$city <- NA # empty ID column (i.e. these polygons don't have a 'city' name
# associated with them)
comb_sf <- rbind(asia_sf['city'], circles_sf['city'])

```

The next step is to flatten the spatial object into a dataframe so that it can be used
in the `mmplot()` function.

Because this work flow currently relies on `create_map_table`, the 
`sf` objects first converted to a `Spatial` object (from the `sp` package),
before it is then converted into a dataframe for use by micromap.

*Consider alternative work flows.*

```{r, fig.height=8, fig.width=5}

comb_sp <- as(comb_sf, 'Spatial')

comb_df <- create_map_table(comb_sp, IDcolumn = "city")
```


### Create micromap showing basemap

```{r Ch6-micromap2, fig.cap = 'Micromap showing the 10 largest cities in asia', fig.width = 5, fig.height = 3}
mmplot(stat.data=cities,
       map.data=comb_df,
        panel.types=c("labels", "dot", "map"),
       panel.data=list("city","population", NA),
       ord.by="population", grouping=5,
       map.link=c("city","ID"),
       panel.att = list(
         list(2, panel.width = 0.5),
         list(2, panel.width = 0.75),
         list(3,
              # the 'ID' column is null for polygons of the underlying basemap
              # so to show those (and therefore show the underlying basemap),
              # map.all needs to be TRUE, otherwise only the circles showing
              # the point locations will appear
              map.all = TRUE,
              active.border.color = 'black', 
              active.border.size = 0.3,
              inactive.border.color = "gray", 
              inactive.border.size = 0.3, 
              panel.width = 1, 
              outer.hull =  FALSE, # shows outside of map
              # this is required to see all map borders:
              nodata.border.color = "black", 
              nodata.border.size = 0.5,
              outer.hull.size = 0.5))
)
```


## County seats in Utah {#Ch6-Example2}

For this example we will look at point location data in Utah. Specifically,
29 towns & cities in Utah, which are the County seats of the 29 counties in the
state. 

First we load the point locations, this is a simple features dataframe,
which provides the name the county seat, as well as its elevation, popolation,
coordinates, and the name of the county. 


```{r}
seats1 <- readRDS("data/Ch6-data/utah_counties.RDS")
class(seats1)
names(seats1)
```

Next we want to load the spatial dataset showing the polygons of counties
in Utah, which we can use as basemap for the micromap. 

```{r cache = TRUE, message = FALSE, results='hide'}
county_polygon <- tigris::counties("Utah", cb = TRUE,
                                   year = 2020)
```

First it is important to check whether the base map
and point locations have the same coordinate reference system


```{r}
st_crs(county_polygon)$proj4string
st_crs(seats1)$proj4string

```

Since they are different, one of the files needs to be re-projected. 

```{r }
seats2 <- st_transform(seats1, crs = st_crs(county_polygon))

```

### Adjust point locations

Figure \@ref(fig:Ch6-CountyMap) shows that some county seats are quite close
to each other, especially in the north-central portion of the state. 
Therefore we may want to adjust the locations of some of these
points so that they don't fully overlap in the final micromap. 


```{r Ch6-CountyMap, fig.cap="Locations of counties and county seats (points), in Utah."}
plot(county_polygon$geometry)
plot(seats2$geometry, add = TRUE, pch = 19, col = 'blue ')
```

For county seats that are close together we can replace the coordinates of 
the county seat with the centroid of the county. That way we can avoid
excessive over-plotting of the points on the micromap while still having
the points appear in the correct county. In a case like this the user needs to
consider how they want to balance being able to see all points
in the micromap, with limited overlap, versus showing the correct positions of 
the points. In example 1
this wasn't an issue because the points of interest were well spaced 
apart. 

Here there are five county seats we could consider moving apart.

First we create a vector of names of counties we want to calculate centroids, 
and then calculate the polygon centroid using the `st_centroid()` function.  

```{r warning = FALSE}
county_names <- c("Weber", "Morgan", "Davis", "Salt Lake", "Summit", "Wasatch",
                  "Box Elder")

centroids <- county_polygon %>% 
  filter(NAME %in% county_names) %>% 
  st_centroid()
```

Now replace the coordinates of the county seats with the centroids of the county. 
Note here we're arranging county names in alphabetical order so that
that the correct coordinates are replaced. 

```{r}
county_names <- sort(county_names)
seats_adjust1 <- seats2 %>% 
  arrange(county)
seats_adjust1$geometry[seats_adjust1$county %in% county_names] <- 
  centroids$geometry
```

Figure \@ref(fig:Ch6-CountyMap2) shows the effect of adjusting these points. 

```{r Ch6-CountyMap2, fig.cap="Original locations of county seats in blue, and adjusted locations in red."}

plot(county_polygon$geometry)
plot(seats2$geometry[seats2$county %in% county_names], add = TRUE, 
     pch = 19, col = 'blue')
plot(seats_adjust1$geometry[seats_adjust1$county %in% county_names], 
     add = TRUE, pch = 19, col = 'red')

```

### Prepare points and basemap for `mmplot()` 

Now that we have adjust the point locations, we need to create circular
polgyons around the points, that will be displayed on the micromap. 


```{r}
seats_circles <- points2circles(seats_adjust1, radius = 8)
```

Next the circles (representing the county seats) need to be combined
with county polygons which is the base map. 

To be able to bind the two objects the `county_polygon`  have an empty county_seats
column.

```{r}
county_polygon$county_seat <- NA
seat_map <- rbind(county_polygon['county_seat'], 
                  seats_circles['county_seat'])

```

The `seat_map` object is simple features dataframe (class `sf`), which needs to be converted
to a `Spatial` object before it can be flattened into a regular dataframe using
`create_map_table` function.

```{r}
seat_map_df <- create_map_table(as(seat_map, 'Spatial'), 
                                IDcolumn = "county_seat") 
```


### Create micromap

Note that the stat.data argument must be passed a dataframe, and the class of
`seats1` is `sf`. In the `st_drop_geometry` function is used to drop the geometry
column (i.e., the coordinates), and convert the object to a dataframe. 

```{r Ch6-MicromapSeat, fig.cap = "Micromap showing the elevations of county seats in Utah. Some locations have been adjusted to decrease overplotting", fig.width = 5, fig.height = 7}
seats_df <- st_drop_geometry(seats1)
mmplot(stat.data = seats_df,
       map.data = seat_map_df,
       panel.types = c("labels", "dot", "map"),
       panel.data = list("county_seat","elevation", NA),
       ord.by = "elevation", 
       grouping=5,
       map.link=c('county_seat', "ID"),
       panel.att = list(
         list(1, header = "County Seat", 
              panel.width = 1),
         list(2, header = "Elevation",
              xaxis.title = "feet",
              panel.width = 1.8),
         list(3, header = "Light Gray Means\nHighlighted Above",
              map.all = TRUE,
              active.border.color = 'black', 
              active.border.size = 0.3,
              inactive.border.color = "gray", 
              inactive.border.size = 0.3, 
              panel.width = 1, 
              outer.hull =  FALSE,
              nodata.border.color = "black", 
              nodata.border.size = 0.5,
              outer.hull.size = 0.5))
)

```

## Premier league football stadiums {#Ch6-Example3}

For this example we will be using using locations of premier league football 
stadiums. A challenge with this data set is being able to properly visualize multiple
locations that are very close together, such as the several stadiums located
in London. This is likely to be a common issue that a
user will run into, where locations are clustered around, for example, urban areas.

Here we will need to jitter the locations of stadiums that are too close together so that
they remain visible in the final micromap. 

[This example, should also include a more refined micromap where more parameters
are used to make the final product publication quality.]

### Obtain point locations

Note the overlap between points

```{r}
stadiums <- readRDS("data/Ch6-data/stadiums.RDS")
head(stadiums)

stadium_circles <- points2circles(stadiums, radius = 8)
```

### Acquire the underlying map

```{r}
uk_map <- wrld_simpl[wrld_simpl@data$NAME == "United Kingdom", ]
uk_map_crop <- raster::crop(uk_map, raster::extent(-5, 50, 0, 56))
uk_map_sf <- st_as_sf(uk_map_crop)
uk_map_sf$stadium <- NA
```

### Combine with points

```{r}

stadiums_map1 <- rbind(uk_map_sf['stadium'], stadium_circles['stadium'])

stadiums_map_df <- create_map_table(as(stadiums_map1, 'Spatial'), 
                                    IDcolumn = "stadium")
```

### Create initial micromap

This is an example of the micromap with point locations not adjusted 
(i.e. still overlapping),
the next section will show how to adjust the locations of these points.

```{r Ch6-micromap4, fig.cap = 'Micromap showing stadium locations, note that these maps aren not very readable due to the overlap in locations', fig.width = 5, fig.height = 7}
mmplot(stat.data=st_drop_geometry(stadiums),
       map.data=stadiums_map_df,
      panel.types=c("labels", "dot", "map"),
       panel.data=list("stadium","capacity", NA),
       ord.by="capacity", grouping=5,
       map.link=c('stadium', "ID"),
       panel.att = list(
         list(1, panel.width = 1.8),
         list(3,
              # the 'ID' column is null for polygons of the underlying basemap
              # so to show those (and therefore show the underlying basemap),
              # map.all needs to be TRUE, otherwise only the circles showing
              # the point locations will appear
              map.all = TRUE,
              active.border.color = 'black', 
              active.border.size = 0.3,
              inactive.border.color = "gray", 
              inactive.border.size = 0.3, 
              panel.width = 1, 
              outer.hull =  FALSE, # shows outside of map
              # this is required to see all map borders:
              nodata.border.color = "black", 
              nodata.border.size = 0.5,
              outer.hull.size = 0.5))
)
```

### Micromap with adjusted stadium locations

The the `point_repel()` function can be used to repel points that are too 
close together, so that in this case the cluster of stadiums in London
don't all over-plot each other. Here some of the default arguments in `point_repel()` 
were changed (`rep.fact` & `adj.max`) to increase the distance between points.
The default arguments may need to be adjustment to obtain satisfactory repulsion
between points. Note that points that are already far apart are not moved. 

```{r}
stadiums_repel <- point_repel(stadiums, rep.fact = 50, adj.max = 1)
par(mfrow = c(1, 2))
plot(stadiums$geometry, main = 'Original point locations')
plot(stadiums_repel$geometry, main = 'Repelled points')
```

Now circles need to be drawn around the points.

```{r}
stadium_circles_repel <- points2circles(stadiums_repel)

stadiums_map_repel <- rbind(uk_map_sf['stadium'], 
                            stadium_circles_repel['stadium'])

stadiums_map_repel_df <- create_map_table(as(stadiums_map_repel, 'Spatial'), 
                                    IDcolumn = "stadium")
```


```{r Ch6-micromap5, fig.cap = 'Micromap showing stadium locations. Here the stadium locations have been moved slightly so that complete overlap of points does not occur. Micromaps can contain two label columns, as seen here where both the stadium name and team name are provided.', fig.width = 7.5, fig.height = 7}
mmplot(stat.data=st_drop_geometry(stadiums),
       map.data=stadiums_map_repel_df,
      panel.types=c("labels", "dot", "map", "labels"),
       panel.data=list("stadium","capacity", NA, "team"),
       ord.by="capacity", grouping=5,
       map.link=c('stadium', "ID"),
       panel.att = list(
         list(1, panel.width = 1.8),
         list(4, panel.width = 1.8, align = 'left'),
         list(3,
              map.all = TRUE,
              active.border.color = 'black', 
              active.border.size = 0.3,
              inactive.border.color = "gray", 
              inactive.border.size = 0.3, 
              panel.width = 1, 
              outer.hull =  FALSE, 
              nodata.border.color = "black", 
              nodata.border.size = 0.5,
              outer.hull.size = 0.5))
)
```

## Further Reading {#Ch6-FurtherReading}

Introduce cross-references to other chapters, e.g., Chapter \@ref(Ch1) and Chapter \@ref(Ch2),
where related work and further examples can be found in this book that match the content of this
chapter, that follow up on this chapter, or that are a prerequisite of this chapter.

Also, do some scientific literature review here that is specific to your chapter.
Where has this R package been introduced and used before, where have other plot types
or different countries been used in micromaps, what were other applications 
of micromaps that are related to the title and content of your chapter, etc.?


\printbibliography[segment=\therefsegment,heading=subbibliography]

