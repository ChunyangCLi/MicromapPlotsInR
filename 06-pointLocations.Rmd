# Linked Micromap Plots for Point Locations {#Ch6}


\chapterauthor{Martin Holdrege, J{\"u}rgen Symanzik}


A few stand-alone attempts have been made in the past to create linked micromap plots 
for point locations such as climate stations and cities, rather than for areal locations. 
This requires that the point location is extended to a small (circular or quadratic) 
area that can be color-coded in a linked micromap plot. This chapter provides an 
overview of necessary steps to produce linked micromap plots for point locations 
to create areas of suitable sizes and to avoid overplotting of nearby point locations.

## Notes [to be deleted later]

To do:
-Create a function that creates polygons (circles) around points,
at least allow this function to work with dataframe and sf objects as inputs
(possible function name `points2circles()`) [this function is now drafted]
-create another function that will combine the circles with a background map
(this could be called `create_spatial_points_map()`)

-create function to jitter point locations (before circles are drawn) (this
function could be called `adjust_points()`)
-down the road maybe consider being able to jitter point locations within
a polygon (e.g., so the county seat point location stays within the county 
polygon)


## Introduction: The challenge of displaying point data using micromaps

The main challenge is that the user must create polygons to represent the 
point locations. The more standard use of micromaps displays data associated 
with polygons (e.g., countries, states, etc.). In the case of point locations,
individual point locations need to displayed on the 
map as a circles (or other shape). The center of a  circle are the coordinates of a given point location.
Once the polygons are created, maps and accompanying data can be visualized 
using the  **micromap**\index{R Packages!micromap} [@PaOl2015] package, 
which requires that each entity for which data
is displayed is a polygon on the map.

Specific challenges when creating the polygons (circles) that that are displayed on the 
micromap, is that they
need to be appropriately sized and should not overlap too much. 
Lastly these circles need to be integrated into a base map that shows geographic
boundaries of interest. 

## Outline of steps that need to be accomplished to create micromaps of point locations

Broadly the following steps need be followed to display point locations
on linked-micromaps.

\begin{enumerate}
   \item Obtain coordinates of the point locations of interest along with 
  the corresponding data.
  \item Obtain geographic data for underlying map that the user wishes
  to display 
  (as described in Chapter X [link to appropriate chapter]).
  \item If needed, repel points that are close to each other, to limit
  overlap in the final map. \textit{This step could be achieved by a provided function
  where the user inputs the size (radius, as percent of range in x) of the
  eventual circles, and this would define how far points should be repelled
  from each other.}
  \item Generate buffer polygons (circles) around points, based on user defined
  radius. \textit{The `sf` package has a function to do this, and a wrapper could be
  built around that. The main challenge will be how to create an `sf` object
  if users start with an object that is not easily coerced to the needed class.}
  \item Make sure both underlying map and polygons have same projection (and
  re-project if needed).
  \item Combine underlying map and polygons into a single object 
  (e.g. class of `sf`). \textit{A function could be built to help facilitate this,
  for an `rbind` to work both the underlying map and the circles need to have the same
  columns, but the `ID` column will be filled with `NA` for the features that 
  just outline the underlying map.}
  \item Flatten the combined object into a dataframe that can be used by 
  `micromap`.
  \item Create linked-micromap.
  \item Iterate such that size of the circles and their level of overlap
  is adequate.
\end{enumerate}

*I need to think further about which of these steps should be automated 
using functions, which type of spatial objects those functions should be able
to handle, and whether those functions can be added to an existing package 
(e.g. `micromap`). The challenge will be to make the workflow as simple as
possible while still flexible, especially given the wide variety of object
classes people may want to be able to start with.*

Once the main hurdles have been outlined (above), the remainder of the chapter
should provide examples using real data. 


## Example 1: Plot large cities in Asia

[This should be the simplest example]

Here we will be visualizing the locations of the 10 largest cities
in Asia, and their associated populations. 

Loading necessary dependencies

```{r message = FALSE, warning=FALSE}
library(micromap)
library(maptools)
library(sf)
library(dplyr)
source("R/Ch6_functions.R")
```


Load the point locations of the cities

```{r}
cities <- readRDS("data/Ch6-data/asian_cities.RDS")

cities$population <- cities$population/10^6 # convert to population in millions
cities <- cities %>% 
  # the 'id' column will be the city name
  rename(ID = city)
head(cities)
```

Note, that when examining the locations of the cities, none of the 
the cities are very close together, so when we draw circles around the point
locations we won't need to be worried about undo overlap in the final maps. 

```{r}
plot(cities$long, cities$lat, xlab = "Longitude", ylab = 'Latitude')
```


### Generate polygons from points

The next step is to draw polygons (circles) around the points. 

To limit the size of the final object the `nQuadSegs` argument should be
given a low value such that the circle is drawn using few lines 
(`nQuadSegs = 1` creates a square).

[For this example just define radius of the circle, without using
an algorithm--later examples can automate that step]


```{r}
circles_sf <- points2circles(cities, coords = c("long", "lat"), 
                             crs = "EPSG:4326")

```

Because this work flow currently relies on `create_map_table`, the 
`sf` objects first converted to a `Spatial` object (from the `sp` package),
before it is then converted into a dataframe for use by micromap.

```{r}
circles_df <- create_map_table(as(circles_sf, 'Spatial'), 
                               IDcolumn = "ID")

```

### Create micromap

This first example shows the locations of the cities, but doesn't have a base map.
The next step is join the point locations with a base map. 

```{r Ch6-micromap1, fig.cap = 'Micromap showing the 10 largest cities in asia. Note that locations of cities are shown, but there are no country polygons to indicate the location of cities', fig.width = 4, fig.height = 3}
mmplot(stat.data=cities,
       map.data=circles_df,
        panel.types=c("labels", "dot", "map"),
       panel.data=list("ID","population", NA),
       ord.by="population", grouping=5,
       map.link=c("ID","ID"))
```

### Combine point locations and background map

To make a better micromap the polygons of the point locations need to be combined
with a background map.

[**NOTE--I'll need to determine what part of this workflow will be put
into functions**]

First we're cropping the world map so that only the region of interest is shown.

**Note this code will need to be updated so that it uses newer tools so it doesn't throw
a warning (e.g., don't use wrld_simpl from maptools and don't rely on raster
package?, see note here: https://cran.r-project.org/web/packages/rgeos/index.html
regarding the fact that `rgeos` is being retired in 2023)**

```{r warning = FALSE, message = FALSE}
data('wrld_simpl')
# note this throws a warning: https://gis.stackexchange.com/questions/379693/crop-wrld-simpl-gives-error-after-r-update
asia <- raster::crop(wrld_simpl, raster::extent(24, 145, 8, 47))

asia_sf <- st_as_sf(asia) # convert to simple feature

```

Note, the circles around
the cities and the underlying map need to have the same projection.


```{r}
asia_sf$ID <- NA # empty ID column (i.e. these polygons don't have a 'city' name
# associated with them)
comb_sf <- rbind(asia_sf['ID'], circles_sf['ID'])

```

The next step is to flatten the spatial object into a dataframe so that it can be used
in the `mmplot()` function.

Because this work flow currently relies on `create_map_table`, the 
`sf` objects first converted to a `Spatial` object (from the `sp` package),
before it is then converted into a dataframe for use by micromap.

*Consider alternative work flows.*

```{r, fig.height=8, fig.width=5}

comb_sp <- as(comb_sf, 'Spatial')

comb_df <- create_map_table(comb_sp, IDcolumn = "ID")
```


### Create micromap showing basemap

```{r Ch6-micromap2, fig.cap = 'Micromap showing the 10 largest cities in asia', fig.width = 5, fig.height = 3}
mmplot(stat.data=cities,
       map.data=comb_df,
        panel.types=c("labels", "dot", "map"),
       panel.data=list("ID","population", NA),
       ord.by="population", grouping=5,
       map.link=c("ID","ID"),
       panel.att = list(
         list(2, panel.width = 0.5),
         list(2, panel.width = 0.75),
         list(3,
              # the 'ID' column is null for polygons of the underlying basemap
              # so to show those (and therefore show the underlying basemap),
              # map.all needs to be TRUE, otherwise only the circles showing
              # the point locations will appear
              map.all = TRUE,
              active.border.color = 'black', 
              active.border.size = 0.3,
              inactive.border.color = "gray", 
              inactive.border.size = 0.3, 
              panel.width = 1, 
              outer.hull =  FALSE, # shows outside of map
              # this is required to see all map borders:
              nodata.border.color = "black", 
              nodata.border.size = 0.5,
              outer.hull.size = 0.5))
)
```


## Example 2

Additionally, the more complex example could also include map and point data that
have different projections, and different object classes to start with 

This example could be all county seats within a state
* state with 20-30 counties (so figure doesn't take up entire map)
* don't want move location that are already separate. 
* don't want to move locations outside of their county.

## Example 3: Premier league football stadiums

For this example we will be using using locations of premier league football 
stadiums. A challenge with this data set is being able to properly visualize multiple
locations that are very close together, such as the several stadiums located
in London. This is likely to be a common issue that a
user will run into, where locations are clustered around, for example, urban areas.

Here we will need to jitter the locations of stadiums that are too close together so that
they remain visible in the final micromap. 

[This example, should also include a more refined micromap where more parameters
are used to make the final product publication quality.]

### Obtain point locations

Note the overlap between points

```{r}
stadiums <- readRDS("data/Ch6-data/stadiums.RDS")
head(stadiums)

stadium_circles <- points2circles(stadiums, radius = 8)
```

### Acquire the underlying map

```{r}
uk_map <- wrld_simpl[wrld_simpl@data$NAME == "United Kingdom", ]
uk_map_crop <- raster::crop(uk_map, raster::extent(-5, 50, 0, 56))
uk_map_sf <- st_as_sf(uk_map_crop)
uk_map_sf$stadium <- NA
```

### Combine with points

```{r}

stadiums_map1 <- rbind(uk_map_sf['stadium'], stadium_circles['stadium'])

stadiums_map_df <- create_map_table(as(stadiums_map1, 'Spatial'), 
                                    IDcolumn = "stadium")
```

### Create initial map

This is an example of the micromap with point locations not jittered (i.e. overlapping),
the next section will show how to properly jitter those points

```{r Ch6-micromap4, fig.cap = 'Micromap showing stadium locations, note that these maps aren not very readable due to the overlap in locations', fig.width = 5, fig.height = 7}
mmplot(stat.data=st_drop_geometry(stadiums),
       map.data=stadiums_map_df,
      panel.types=c("labels", "dot", "map"),
       panel.data=list("stadium","capacity", NA),
       ord.by="capacity", grouping=5,
       map.link=c('stadium', "ID"),
       panel.att = list(
         list(1, panel.width = 1.8),
         list(3,
              # the 'ID' column is null for polygons of the underlying basemap
              # so to show those (and therefore show the underlying basemap),
              # map.all needs to be TRUE, otherwise only the circles showing
              # the point locations will appear
              map.all = TRUE,
              active.border.color = 'black', 
              active.border.size = 0.3,
              inactive.border.color = "gray", 
              inactive.border.size = 0.3, 
              panel.width = 1, 
              outer.hull =  FALSE, # shows outside of map
              # this is required to see all map borders:
              nodata.border.color = "black", 
              nodata.border.size = 0.5,
              outer.hull.size = 0.5))
)
```

### Jitter stadium locations

The the `point_repel()` function can be used to repel points that are too 
close together, so that in this case the cluster of stadiums in London
don't all over-plot each other. Here some of the default arguments in `point_repel()` 
were changed (`rep.fact` & `adj.max`) to increase the distance between points.
The default arguments may need to be adjustment to obtain satisfactory repulsion
between points. Note that points that are already far apart are not moved. 

```{r}
stadiums_repel <- point_repel(stadiums, rep.fact = 50, adj.max = 1)
par(mfrow = c(1, 2))
plot(stadiums$geometry, main = 'Original point locations')
plot(stadiums_repel$geometry, main = 'Repelled points')
```

Now circles need to be drawn around the points.

```{r}
stadium_circles_repel <- points2circles(stadiums_repel)

stadiums_map_repel <- rbind(uk_map_sf['stadium'], 
                            stadium_circles_repel['stadium'])

stadiums_map_repel_df <- create_map_table(as(stadiums_map_repel, 'Spatial'), 
                                    IDcolumn = "stadium")
```


```{r Ch6-micromap5, fig.cap = 'Micromap showing stadium locations. Here the stadium locations have been moved slightly so that complete overlap of points does not occur. Micromaps can contain two label columns, as seen here where both the stadium name and team name are provided.', fig.width = 7.5, fig.height = 7}
mmplot(stat.data=st_drop_geometry(stadiums),
       map.data=stadiums_map_repel_df,
      panel.types=c("labels", "dot", "map", "labels"),
       panel.data=list("stadium","capacity", NA, "team"),
       ord.by="capacity", grouping=5,
       map.link=c('stadium', "ID"),
       panel.att = list(
         list(1, panel.width = 1.8),
         list(4, panel.width = 1.8, align = 'left'),
         list(3,
              map.all = TRUE,
              active.border.color = 'black', 
              active.border.size = 0.3,
              inactive.border.color = "gray", 
              inactive.border.size = 0.3, 
              panel.width = 1, 
              outer.hull =  FALSE, 
              nodata.border.color = "black", 
              nodata.border.size = 0.5,
              outer.hull.size = 0.5))
)
```

## Further Reading {#Ch6-FurtherReading}

Introduce cross-references to other chapters, e.g., Chapter \@ref(Ch1) and Chapter \@ref(Ch2),
where related work and further examples can be found in this book that match the content of this
chapter, that follow up on this chapter, or that are a prerequisite of this chapter.

Also, do some scientific literature review here that is specific to your chapter.
Where has this R package been introduced and used before, where have other plot types
or different countries been used in micromaps, what were other applications 
of micromaps that are related to the title and content of your chapter, etc.?


\printbibliography[segment=\therefsegment,heading=subbibliography]

